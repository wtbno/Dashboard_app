"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.distinctByProperty = exports.joinPath = exports.fillServerVariables = exports.parseUrl = exports.getMethodAnnotationName = exports.isHttpMethodKey = exports.HttpMethod = exports.isPluginKey = exports.getPluginNameFromKey = exports.pathVariablesToRegex = exports.generateSlug = exports.getName = exports.getSecurity = exports.getAllServers = exports.getPaths = exports.getServers = void 0;
const slugify_1 = __importDefault(require("slugify"));
const url_1 = __importDefault(require("url"));
const kong_1 = require("./types/kong");
const getServers = (obj) => obj.servers || [];
exports.getServers = getServers;
const getPaths = (obj) => obj.paths || {};
exports.getPaths = getPaths;
function getAllServers(api) {
    const servers = exports.getServers(api);
    for (const path of Object.keys(api.paths)) {
        for (const server of exports.getServers(api.paths[path])) {
            servers.push(server);
        }
    }
    return servers;
}
exports.getAllServers = getAllServers;
const getSecurity = (obj) => (obj === null || obj === void 0 ? void 0 : obj.security) || [];
exports.getSecurity = getSecurity;
function getName(api, defaultValue, slugifyOptions, isKubernetes) {
    var _a, _b, _c;
    let rawName = '';
    // Get $.info.x-kubernetes-ingress-metadata.name
    rawName = isKubernetes ? (_b = (_a = api.info) === null || _a === void 0 ? void 0 : _a['x-kubernetes-ingress-metadata']) === null || _b === void 0 ? void 0 : _b.name : '';
    // Get $.x-kong-name
    rawName = rawName || api[kong_1.xKongName];
    // Get $.info.title
    rawName = rawName || ((_c = api.info) === null || _c === void 0 ? void 0 : _c.title);
    // Make sure the name is a string
    const defaultName = defaultValue || 'openapi';
    const name = typeof rawName === 'string' && rawName ? rawName : defaultName;
    // Slugify
    return generateSlug(name, slugifyOptions);
}
exports.getName = getName;
function generateSlug(str, options = {}) {
    options.replacement = options.replacement || '_';
    options.lower = options.lower || false;
    return slugify_1.default(str, options);
}
exports.generateSlug = generateSlug;
/** characters in curly braces not immediately followed by `://`, e.g. `{foo}` will match but `{foo}://` will not. */
const pathVariableSearchValue = /{([^}]+)}(?!:\/\/)/g;
function pathVariablesToRegex(p) {
    // match anything except whitespace and '/'
    const result = p.replace(pathVariableSearchValue, '(?<$1>[^\\/]+)');
    // add a line ending because it is a regex
    return result + '$';
}
exports.pathVariablesToRegex = pathVariablesToRegex;
function getPluginNameFromKey(key) {
    return key.replace(/^x-kong-plugin-/, '');
}
exports.getPluginNameFromKey = getPluginNameFromKey;
function isPluginKey(key) {
    return key.indexOf('x-kong-plugin-') === 0;
}
exports.isPluginKey = isPluginKey;
exports.HttpMethod = {
    get: 'GET',
    put: 'PUT',
    post: 'POST',
    delete: 'DELETE',
    options: 'OPTIONS',
    head: 'HEAD',
    patch: 'PATCH',
    trace: 'TRACE',
};
function isHttpMethodKey(key) {
    const uppercaseKey = key.toUpperCase();
    return Object.values(exports.HttpMethod).some(method => method === uppercaseKey);
}
exports.isHttpMethodKey = isHttpMethodKey;
function getMethodAnnotationName(method) {
    return `${method}-method`.toLowerCase();
}
exports.getMethodAnnotationName = getMethodAnnotationName;
function parseUrl(urlStr) {
    const parsed = url_1.default.parse(urlStr);
    if (!parsed.port && parsed.protocol === 'https:') {
        parsed.port = '443';
    }
    else if (!parsed.port && parsed.protocol === 'http:') {
        parsed.port = '80';
    }
    parsed.protocol = parsed.protocol || 'http:';
    if (parsed.hostname && parsed.port) {
        parsed.host = `${parsed.hostname}:${parsed.port}`;
    }
    else if (parsed.hostname) {
        parsed.host = parsed.hostname;
    }
    return parsed;
}
exports.parseUrl = parseUrl;
function fillServerVariables(server) {
    let finalUrl = server.url;
    const variables = server.variables || {};
    for (const name of Object.keys(variables)) {
        const defaultValue = variables[name].default;
        if (!defaultValue) {
            throw new Error(`Server variable "${name}" missing default value`);
        }
        finalUrl = finalUrl.replace(`{${name}}`, defaultValue);
    }
    return finalUrl;
}
exports.fillServerVariables = fillServerVariables;
function joinPath(p1, p2) {
    p1 = p1.replace(/\/$/, '');
    p2 = p2.replace(/^\//, '');
    return `${p1}/${p2}`;
}
exports.joinPath = joinPath;
// Select first unique instance of an array item depending on the property selector
function distinctByProperty(arr, propertySelector) {
    const result = [];
    const set = new Set();
    for (const item of arr.filter(i => i)) {
        const selector = propertySelector(item);
        if (set.has(selector)) {
            continue;
        }
        set.add(selector);
        result.push(item);
    }
    return result;
}
exports.distinctByProperty = distinctByProperty;
//# sourceMappingURL=common.js.map