"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSecurityPlugin = exports.generateOAuth2SecurityPlugin = exports.generateOpenIdConnectSecurityPlugin = exports.generateBasicAuthPlugin = exports.generateApiKeySecurityPlugin = exports.generateSecurityPlugins = void 0;
const common_1 = require("../common");
function generateSecurityPlugins(op, api, tags) {
    const plugins = [];
    const components = api.components || {};
    const securitySchemes = components.securitySchemes || {};
    const security = op ? common_1.getSecurity(op) : common_1.getSecurity(api);
    for (const securityItem of security || []) {
        for (const name of Object.keys(securityItem)) {
            const scheme = (securitySchemes[name] || {});
            const args = securityItem[name];
            const plugin = generateSecurityPlugin(scheme, args, tags);
            if (plugin) {
                plugins.push(plugin);
            }
        }
    }
    return plugins;
}
exports.generateSecurityPlugins = generateSecurityPlugins;
const generateApiKeySecurityPlugin = (scheme) => {
    if (!['query', 'header', 'cookie'].includes(scheme.in)) {
        throw new Error(`a ${scheme.type} object expects valid "in" property. Got ${scheme.in}`);
    }
    if (!scheme.name) {
        throw new Error(`a ${scheme.type} object expects valid "name" property. Got ${scheme.name}`);
    }
    const keyAuthPlugin = {
        name: 'key-auth',
        config: {
            key_names: [scheme.name],
        },
    };
    return keyAuthPlugin;
};
exports.generateApiKeySecurityPlugin = generateApiKeySecurityPlugin;
const generateBasicAuthPlugin = (scheme) => {
    if ((scheme.scheme || '').toLowerCase() !== 'basic') {
        throw new Error(`Only "basic" http scheme supported. got ${scheme.scheme}`);
    }
    const basicAuthPlugin = {
        name: 'basic-auth',
    };
    return basicAuthPlugin;
};
exports.generateBasicAuthPlugin = generateBasicAuthPlugin;
const generateOpenIdConnectSecurityPlugin = (scheme, args) => {
    if (!scheme.openIdConnectUrl) {
        throw new Error(`invalid "openIdConnectUrl" property. Got ${scheme.openIdConnectUrl}`);
    }
    const openIdConnectPlugin = {
        name: 'openid-connect',
        config: {
            issuer: scheme.openIdConnectUrl,
            scopes_required: args || [],
        },
    };
    return openIdConnectPlugin;
};
exports.generateOpenIdConnectSecurityPlugin = generateOpenIdConnectSecurityPlugin;
const generateOAuth2SecurityPlugin = () => ({
    config: {
        auth_methods: ['client_credentials'],
    },
    name: 'openid-connect',
});
exports.generateOAuth2SecurityPlugin = generateOAuth2SecurityPlugin;
function generateSecurityPlugin(scheme, args, tags) {
    var _a, _b;
    let plugin = null;
    // Generate base plugin
    switch (scheme === null || scheme === void 0 ? void 0 : scheme.type.toLowerCase()) {
        case 'apikey':
            plugin = exports.generateApiKeySecurityPlugin(scheme);
            break;
        case 'http':
            plugin = exports.generateBasicAuthPlugin(scheme);
            break;
        case 'openidconnect':
            plugin = exports.generateOpenIdConnectSecurityPlugin(scheme, args);
            break;
        case 'oauth2':
            plugin = exports.generateOAuth2SecurityPlugin();
            break;
        default:
            return null;
    }
    // Add additional plugin configuration from x-kong-security-* property
    // Only search for the matching key
    // i.e. OAuth2 security with x-kong-security-basic-auth should not match
    const kongSecurity = (_a = scheme[`x-kong-security-${plugin.name}`]) !== null && _a !== void 0 ? _a : {};
    if (kongSecurity.config) {
        plugin.config = kongSecurity.config;
    }
    // Add global tags
    plugin.tags = [
        ...tags,
        ...((_b = kongSecurity.tags) !== null && _b !== void 0 ? _b : []),
    ];
    return plugin;
}
exports.generateSecurityPlugin = generateSecurityPlugin;
//# sourceMappingURL=security-plugins.js.map