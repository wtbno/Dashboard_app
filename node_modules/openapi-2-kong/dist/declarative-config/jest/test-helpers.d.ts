import { DCPlugin, K8sKongPlugin, K8sKongPluginBase, OpenApi3Spec } from '../../types';
import { PluginBase, XKongPlugin } from '../../types/kong';
export declare const tags: string[];
/** used only for testing */
export interface DummyPlugin extends PluginBase<'dummy'> {
    config: {
        foo: 'bar';
    };
}
export declare type XKongPluginDummy = XKongPlugin<DummyPlugin>;
export declare const pluginDummy: XKongPluginDummy;
export declare const dummyName: (suffix: string) => string;
export declare const dummyPluginDoc: (suffix: string) => K8sKongPluginBase<DummyPlugin>;
/**
 * This simulates what a user would do when creating a custom plugin.
 *
 * In the user's case they would, in practice, use module augmentation to extend DCPlugin, however a simple union achieves the same goal, here.
 */
export declare type UserDCPlugin = DCPlugin | DummyPlugin;
/**
 * This simulates what a user would do when creating a custom plugin.
 *
 * In the user's case they would, in practice, use module augmentation to extend K8sKongPlugin, however a simple union achieves the same goal, here.
 */
export declare type UserK8sPlugin = K8sKongPlugin | K8sKongPluginBase<DummyPlugin>;
/**
 * This simulates what a user would do when creating a custom plugin.
 *
 * In the user's case they would, in practice, use module augmentation to extend K8sKongPlugin, however a simple union achieves the same goal, here.
 */
export declare type UserXKongPlugin = XKongPlugin<Plugin> | XKongPlugin<DummyPlugin>;
/** This function is written in such a way as to allow mutations in tests but without affecting other tests. */
export declare const getSpec: (overrides?: Partial<OpenApi3Spec>) => OpenApi3Spec;
//# sourceMappingURL=test-helpers.d.ts.map