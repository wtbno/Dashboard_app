"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateRouteName = exports.generateService = exports.generateServices = void 0;
const common_1 = require("../common");
const kong_1 = require("../types/kong");
const plugins_1 = require("./plugins");
const security_plugins_1 = require("./security-plugins");
function generateServices(api, tags) {
    const servers = common_1.getAllServers(api);
    if (servers.length === 0) {
        throw new Error('no servers defined in spec');
    }
    // only support one service for now
    const service = generateService(servers[0], api, tags);
    return [service];
}
exports.generateServices = generateServices;
function generateService(server, api, tags) {
    var _a, _b;
    const serverUrl = common_1.fillServerVariables(server);
    const name = common_1.getName(api);
    const parsedUrl = common_1.parseUrl(serverUrl);
    // Service plugins
    const globalPlugins = plugins_1.generateGlobalPlugins(api, tags);
    const serviceDefaults = api[kong_1.xKongServiceDefaults] || {};
    if (typeof serviceDefaults !== 'object') {
        throw new Error(`expected '${kong_1.xKongServiceDefaults}' to be an object`);
    }
    const service = {
        ...serviceDefaults,
        name,
        // remove semicolon i.e. convert `https:` to `https`
        protocol: (_a = parsedUrl === null || parsedUrl === void 0 ? void 0 : parsedUrl.protocol) === null || _a === void 0 ? void 0 : _a.substring(0, parsedUrl.protocol.length - 1),
        host: `${name}.upstream`,
        // not a hostname, but the Upstream name
        port: Number(parsedUrl.port || '80'),
        path: parsedUrl.pathname,
        plugins: globalPlugins.plugins,
        routes: [],
        tags,
    };
    const routeDefaultsRoot = api['x-kong-route-defaults'] || {};
    if (typeof routeDefaultsRoot !== 'object') {
        throw new Error('expected root-level \'x-kong-route-defaults\' to be an object');
    }
    for (const routePath of Object.keys(api.paths)) {
        const pathItem = api.paths[routePath];
        const routeDefaultsPath = api.paths[routePath]['x-kong-route-defaults'] || routeDefaultsRoot;
        if (typeof routeDefaultsPath !== 'object') {
            throw new Error(`expected 'x-kong-route-defaults' to be an object (at path '${routePath}')`);
        }
        const pathValidatorPlugin = plugins_1.getRequestValidatorPluginDirective(pathItem);
        const pathPlugins = plugins_1.generatePlugins(pathItem, tags);
        for (const method of Object.keys(pathItem)) {
            if (method !== 'get' &&
                method !== 'put' &&
                method !== 'post' &&
                method !== 'delete' &&
                method !== 'options' &&
                method !== 'head' &&
                method !== 'patch' &&
                method !== 'trace') {
                continue;
            }
            const operation = pathItem[method];
            const routeDefaultsOperation = ((_b = pathItem === null || pathItem === void 0 ? void 0 : pathItem[method]) === null || _b === void 0 ? void 0 : _b['x-kong-route-defaults']) || routeDefaultsPath;
            if (typeof routeDefaultsOperation !== 'object') {
                throw new Error(`expected 'x-kong-route-defaults' to be an object (at operation '${method}' of path '${routePath}')`);
            }
            if (!operation) {
                continue;
            }
            // Create the base route object
            const fullPathRegex = common_1.pathVariablesToRegex(routePath);
            const route = {
                ...routeDefaultsOperation,
                tags,
                name: generateRouteName(api, routePath, method),
                methods: [method.toUpperCase()],
                paths: [fullPathRegex],
            };
            if (route.strip_path === undefined) {
                // must override the Kong default of 'true' since we match based on full path regexes, which would lead Kong to always strip the full path down to a single '/' if it used that default.
                route.strip_path = false;
            }
            // Generate generic and security-related plugin objects
            const securityPlugins = security_plugins_1.generateSecurityPlugins(operation, api, tags);
            // Path plugin takes precedence over global
            const parentValidatorPlugin = pathValidatorPlugin || globalPlugins.requestValidatorPlugin;
            const regularPlugins = plugins_1.generateOperationPlugins({
                operation,
                pathPlugins,
                parentValidatorPlugin,
                tags,
            });
            const plugins = [...regularPlugins, ...securityPlugins];
            // Add plugins if there are any
            if (plugins.length) {
                route.plugins = plugins;
            }
            service.routes.push(route);
        }
    }
    return service;
}
exports.generateService = generateService;
function generateRouteName(api, routePath, method) {
    var _a, _b, _c, _d;
    const name = common_1.getName(api);
    const pathItem = api.paths[routePath];
    if (typeof ((_a = pathItem === null || pathItem === void 0 ? void 0 : pathItem[method]) === null || _a === void 0 ? void 0 : _a[kong_1.xKongName]) === 'string') {
        const opsName = common_1.generateSlug((_b = pathItem === null || pathItem === void 0 ? void 0 : pathItem[method]) === null || _b === void 0 ? void 0 : _b[kong_1.xKongName]);
        return `${name}-${opsName}`;
    }
    if ((_c = pathItem === null || pathItem === void 0 ? void 0 : pathItem[method]) === null || _c === void 0 ? void 0 : _c.operationId) {
        const opsName = common_1.generateSlug((_d = pathItem === null || pathItem === void 0 ? void 0 : pathItem[method]) === null || _d === void 0 ? void 0 : _d.operationId);
        return `${name}-${opsName}`;
    }
    // replace all `/` with `-` except the ones at the beginning or end of a string
    const replacedRoute = routePath.replace(/(?!^)\/(?!$)/g, '-');
    const pathSlug = common_1.generateSlug(pathItem[kong_1.xKongName] || replacedRoute);
    return `${name}${pathSlug ? `-${pathSlug}` : ''}-${method}`;
}
exports.generateRouteName = generateRouteName;
//# sourceMappingURL=services.js.map