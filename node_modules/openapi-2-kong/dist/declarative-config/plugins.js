"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getRequestValidatorPluginDirective = exports.generateOperationPlugins = exports.generateGlobalPlugins = exports.generateRequestValidatorPlugin = exports.ALLOW_ALL_SCHEMA = exports.generatePlugins = exports.isRequestValidatorPluginKey = void 0;
const common_1 = require("../common");
const kong_1 = require("../types/kong");
const isRequestValidatorPluginKey = (property) => (property.match(/-request-validator$/) != null);
exports.isRequestValidatorPluginKey = isRequestValidatorPluginKey;
function generatePlugins(item, tags) {
    // When generating plugins, ignore the request validator plugin because it is handled at the operation level
    const pluginFilter = ([key]) => common_1.isPluginKey(key) && !exports.isRequestValidatorPluginKey(key);
    // Server plugins should load from the api spec root and from the server
    return Object.entries(item)
        .filter(pluginFilter)
        .map(generatePlugin(tags));
}
exports.generatePlugins = generatePlugins;
const generatePlugin = (tags) => ([key, value]) => {
    var _a;
    return ({
        ...(value !== null && value !== void 0 ? value : {}),
        name: value.name || common_1.getPluginNameFromKey(key),
        tags: [
            // Add tags to plugins while appending defaults tags
            ...tags,
            ...((_a = value.tags) !== null && _a !== void 0 ? _a : []),
        ],
    });
};
/**
 * This is valid config to allow all content to pass
 * See: https://github.com/Kong/kong-plugin-enterprise-request-validator/pull/34/files#diff-1a1d2d5ce801cc1cfb2aa91ae15686d81ef900af1dbef00f004677bc727bfd3cR284
 */
exports.ALLOW_ALL_SCHEMA = '{}';
const DEFAULT_PARAM_STYLE = {
    header: 'simple',
    cookie: 'form',
    query: 'form',
    path: 'simple',
};
const generateParameterSchema = (operation) => {
    var _a, _b;
    if (!((_a = operation === null || operation === void 0 ? void 0 : operation.parameters) === null || _a === void 0 ? void 0 : _a.length)) {
        return undefined;
    }
    const parameterSchemas = [];
    for (const parameter of operation.parameters) {
        // The following is valid config to allow all content to pass, in the case where schema is not defined
        let schema = '';
        if (parameter.schema) {
            schema = JSON.stringify(parameter.schema);
        }
        else if (parameter.content) {
            // only parameters defined with a schema (not content) are supported
            schema = exports.ALLOW_ALL_SCHEMA;
        }
        else {
            // no schema or content property on a parameter is in violation with the OpenAPI spec
            schema = exports.ALLOW_ALL_SCHEMA;
        }
        const paramStyle = (_b = parameter.style) !== null && _b !== void 0 ? _b : DEFAULT_PARAM_STYLE[parameter.in];
        if (typeof paramStyle === 'undefined') {
            const name = parameter.name;
            throw new Error(`invalid 'in' property (parameter '${name}')`);
        }
        const parameterSchema = {
            in: parameter.in,
            explode: !!parameter.explode,
            required: !!parameter.required,
            name: parameter.name,
            schema,
            style: paramStyle,
        };
        parameterSchemas.push(parameterSchema);
    }
    return parameterSchemas;
};
function generateBodyOptions(operation) {
    var _a;
    let bodySchema;
    let allowedContentTypes;
    const bodyContent = (_a = operation === null || operation === void 0 ? void 0 : operation.requestBody) === null || _a === void 0 ? void 0 : _a.content;
    if (bodyContent) {
        const jsonContentType = 'application/json';
        allowedContentTypes = Object.keys(bodyContent);
        if (allowedContentTypes.includes(jsonContentType)) {
            const item = bodyContent[jsonContentType];
            bodySchema = JSON.stringify(item.schema);
        }
    }
    return {
        bodySchema,
        allowedContentTypes,
    };
}
function generateRequestValidatorPlugin({ plugin = { name: 'request-validator' }, tags, operation, }) {
    var _a, _b, _c, _d, _e;
    const config = {
        version: 'draft4',
    };
    // // Use original or generated parameter_schema
    const parameterSchema = kong_1.isParameterSchema(plugin.config) ? plugin.config.parameter_schema : generateParameterSchema(operation);
    const generated = generateBodyOptions(operation);
    // Use original or generated body_schema
    let bodySchema = kong_1.isBodySchema(plugin.config) ? plugin.config.body_schema : generated.bodySchema;
    // If no parameter_schema or body_schema is defined or generated, allow all content to pass
    if (parameterSchema === undefined && bodySchema === undefined) {
        bodySchema = exports.ALLOW_ALL_SCHEMA;
    }
    // Apply parameter_schema and body_schema to the config object
    if (parameterSchema !== undefined) {
        config.parameter_schema = parameterSchema;
    }
    if (bodySchema !== undefined) {
        config.body_schema = bodySchema;
    }
    // Use original or generated allowed_content_types
    const allowedContentTypes = (_b = (_a = plugin.config) === null || _a === void 0 ? void 0 : _a.allowed_content_types) !== null && _b !== void 0 ? _b : generated.allowedContentTypes;
    if (allowedContentTypes !== undefined) {
        config.allowed_content_types = allowedContentTypes;
    }
    // Use original verbose_response if defined
    if (((_c = plugin.config) === null || _c === void 0 ? void 0 : _c.verbose_response) !== undefined) {
        config.verbose_response = Boolean(plugin.config.verbose_response);
    }
    const isEnabledSpecified = Object.prototype.hasOwnProperty.call(plugin, 'enabled');
    const enabled = isEnabledSpecified ? { enabled: Boolean((_d = plugin.enabled) !== null && _d !== void 0 ? _d : true) } : {};
    const requestValidatorPlugin = {
        name: 'request-validator',
        config: config,
        tags: [
            ...(tags !== null && tags !== void 0 ? tags : []),
            ...((_e = plugin.tags) !== null && _e !== void 0 ? _e : []),
        ],
        ...enabled,
    };
    return requestValidatorPlugin;
}
exports.generateRequestValidatorPlugin = generateRequestValidatorPlugin;
function generateGlobalPlugins(api, tags) {
    const globalPlugins = generatePlugins(api, tags);
    const plugin = exports.getRequestValidatorPluginDirective(api);
    if (plugin) {
        globalPlugins.push(generateRequestValidatorPlugin({ plugin, tags }));
    }
    return {
        // Server plugins take precedence over global plugins
        plugins: common_1.distinctByProperty(globalPlugins, plugin => plugin.name),
        requestValidatorPlugin: plugin,
    };
}
exports.generateGlobalPlugins = generateGlobalPlugins;
const generateOperationPlugins = ({ operation, pathPlugins, parentValidatorPlugin, tags }) => {
    const operationPlugins = generatePlugins(operation, tags);
    // Check if validator plugin exists on the operation, even if the value of the plugin is undefined
    const operationValidatorPlugin = exports.getRequestValidatorPluginDirective(operation);
    // Use the operation or parent validator plugin, or skip if neither exist
    const plugin = operationValidatorPlugin || parentValidatorPlugin;
    if (plugin) {
        operationPlugins.push(generateRequestValidatorPlugin({ plugin, tags, operation }));
    }
    // Operation plugins take precedence over path plugins
    return common_1.distinctByProperty([...operationPlugins, ...pathPlugins], plugin => plugin.name);
};
exports.generateOperationPlugins = generateOperationPlugins;
/** This function accepts any OpenAPI3 document segment that can have the request validator plugin and returns it if found */
const getRequestValidatorPluginDirective = (segment) => {
    const key = Object.keys(segment).filter(common_1.isPluginKey).find(exports.isRequestValidatorPluginKey);
    // If the key is defined but is blank (therefore should be fully generated) then default to {}, which is truthy.
    return key ? (segment[key] || {}) : undefined;
};
exports.getRequestValidatorPluginDirective = getRequestValidatorPluginDirective;
//# sourceMappingURL=plugins.js.map