"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prioritizePlugins = exports.normalizeOperationPlugins = exports.normalizePathPlugins = exports.generateK8sPluginConfig = exports.getOperationPlugins = exports.getPathPlugins = exports.getServerPlugins = exports.getGlobalPlugins = exports.mapDcPluginsToK8sPlugins = exports.getPlugins = exports.flattenPluginDocuments = void 0;
const common_1 = require("../common");
const security_plugins_1 = require("../declarative-config/security-plugins");
function flattenPluginDocuments(plugins) {
    const all = [];
    const { global, servers, paths } = plugins;
    all.push(...global);
    servers.forEach(s => {
        all.push(...s.plugins);
    });
    paths.forEach(s => {
        all.push(...s.plugins);
        s.operations.forEach(o => {
            all.push(...o.plugins);
        });
    });
    return all;
}
exports.flattenPluginDocuments = flattenPluginDocuments;
function getPlugins(api) {
    let _iterator = 0;
    const increment = () => _iterator++;
    const servers = common_1.getServers(api);
    // if no global servers
    if (servers.length === 0) {
        throw new Error('Failed to generate spec: no servers defined in spec.');
    }
    const paths = common_1.getPaths(api);
    return {
        global: getGlobalPlugins(api, increment),
        servers: getServerPlugins(servers, increment),
        paths: getPathPlugins(paths, increment, api),
    };
}
exports.getPlugins = getPlugins;
// NOTE: It isn't great that we're relying on declarative-config stuff here but there's
// not much we can do about it. If we end up needing this again, it should be factored
// out to a higher-level.
function mapDcPluginsToK8sPlugins(dcPlugins, suffix, increment) {
    return dcPlugins.map(dcPlugin => {
        const k8sPlugin = {
            apiVersion: 'configuration.konghq.com/v1',
            kind: 'KongPlugin',
            metadata: {
                name: `add-${dcPlugin.name}-${suffix}${increment()}`,
            },
            plugin: dcPlugin.name,
        };
        if (dcPlugin.config) {
            k8sPlugin.config = dcPlugin.config;
        }
        return k8sPlugin;
    });
}
exports.mapDcPluginsToK8sPlugins = mapDcPluginsToK8sPlugins;
function getGlobalPlugins(api, increment) {
    const pluginNameSuffix = PluginNameSuffix.global;
    const globalK8sPlugins = generateK8sPluginConfig(api, pluginNameSuffix, increment);
    const securityPlugins = mapDcPluginsToK8sPlugins(security_plugins_1.generateSecurityPlugins(null, api, []), pluginNameSuffix, increment);
    return [...globalK8sPlugins, ...securityPlugins];
}
exports.getGlobalPlugins = getGlobalPlugins;
function getServerPlugins(servers, increment) {
    return servers.map(server => ({
        server,
        plugins: generateK8sPluginConfig(server, PluginNameSuffix.server, increment),
    }));
}
exports.getServerPlugins = getServerPlugins;
function getPathPlugins(paths, increment, api) {
    const pathPlugins = Object.keys(paths).map(path => {
        const pathItem = paths[path];
        return {
            path,
            plugins: generateK8sPluginConfig(pathItem, PluginNameSuffix.path, increment),
            operations: exports.normalizeOperationPlugins(getOperationPlugins(pathItem, increment, api)),
        };
    });
    return normalizePathPlugins(pathPlugins);
}
exports.getPathPlugins = getPathPlugins;
function getOperationPlugins(pathItem, increment, api) {
    const operationPlugins = Object.keys(pathItem)
        .filter(common_1.isHttpMethodKey)
        .map(key => {
        // We know this will always, only be OA3Operation (because of the filter above)
        const operation = pathItem[key];
        const pluginNameSuffix = PluginNameSuffix.operation;
        const opPlugins = generateK8sPluginConfig(operation, pluginNameSuffix, increment);
        const securityPlugins = mapDcPluginsToK8sPlugins(security_plugins_1.generateSecurityPlugins(operation, api, []), pluginNameSuffix, increment);
        return {
            method: key,
            plugins: [...opPlugins, ...securityPlugins],
        };
    });
    return exports.normalizeOperationPlugins(operationPlugins);
}
exports.getOperationPlugins = getOperationPlugins;
// When a plugin name is generated during parsing, we suffix it with where it was sourced from and an index.
// For example, the third plugin parsed may be on the path, so it would have the (zero-indexed) name add-key-auth-p2
const PluginNameSuffix = {
    global: 'g',
    server: 's',
    path: 'p',
    operation: 'm',
};
function generateK8sPluginConfig(obj, pluginNameSuffix, increment) {
    const plugins = [];
    for (const key of Object.keys(obj).filter(common_1.isPluginKey)) {
        const pData = obj[key];
        const name = pData.name || common_1.getPluginNameFromKey(key);
        const p = {
            apiVersion: 'configuration.konghq.com/v1',
            kind: 'KongPlugin',
            metadata: {
                name: `add-${name}-${pluginNameSuffix}${increment()}`,
            },
            plugin: name,
        };
        if (pData.config) {
            p.config = pData.config;
        }
        plugins.push(p);
    }
    return plugins;
}
exports.generateK8sPluginConfig = generateK8sPluginConfig;
const blankOperation = {
    method: null,
    plugins: [],
};
const blankPath = {
    path: '',
    plugins: [],
    operations: [blankOperation],
};
function normalizePathPlugins(pathPlugins) {
    const pluginsExist = pathPlugins.some(p => (p.plugins.length || p.operations.some(o => o.plugins.length)));
    return pluginsExist ? pathPlugins : [blankPath];
}
exports.normalizePathPlugins = normalizePathPlugins;
const normalizeOperationPlugins = (operationPlugins) => {
    const pluginsExist = operationPlugins.some(operation => operation.plugins.length);
    return pluginsExist ? operationPlugins : [blankOperation];
};
exports.normalizeOperationPlugins = normalizeOperationPlugins;
function prioritizePlugins(global, server, path, operation) {
    // Order in priority: operation > path > server > global
    const plugins = [...operation, ...path, ...server, ...global];
    // Select first of each type of plugin
    return common_1.distinctByProperty(plugins, p => p.plugin);
}
exports.prioritizePlugins = prioritizePlugins;
//# sourceMappingURL=plugins.js.map