"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = exports.description = exports.name = exports.id = void 0;
exports.id = 'postman';
exports.name = 'Postman';
exports.description = 'Importer for Postman collections';
let requestCount = 1;
let requestGroupCount = 1;
const POSTMAN_SCHEMA_V2_0 = 'https://schema.getpostman.com/json/collection/v2.0.0/collection.json';
const POSTMAN_SCHEMA_V2_1 = 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json';
class ImportCollection {
    constructor(collection) {
        this.importVariable = (variables) => {
            if ((variables === null || variables === void 0 ? void 0 : variables.length) === 0) {
                return null;
            }
            const variable = {};
            for (let i = 0; i < variables.length; i++) {
                const key = variables[i].key;
                if (key === undefined) {
                    continue;
                }
                variable[key] = variables[i].value;
            }
            return variable;
        };
        this.importItems = (items, parentId = '__WORKSPACE_ID__') => {
            // @ts-expect-error this is because there are devergent behaviors for how the function treats this collection.  This is handled appropriately in the function itself in different branches.
            return items.reduce((accumulator, item) => {
                if (Object.prototype.hasOwnProperty.call(item, 'request')) {
                    return [...accumulator, this.importRequestItem(item, parentId)];
                }
                const requestGroup = this.importFolderItem(item, parentId);
                return [
                    ...accumulator,
                    requestGroup,
                    ...this.importItems(item.item, requestGroup._id),
                ];
            }, []);
        };
        this.importRequestItem = ({ request, name = '' }, parentId) => {
            var _a;
            if (typeof request === 'string') {
                return {};
            }
            return {
                parentId,
                _id: `__REQ_${requestCount++}__`,
                _type: 'request',
                name,
                description: request.description || '',
                url: this.importUrl(request.url),
                method: request.method || 'GET',
                headers: (_a = (request.header || [])) === null || _a === void 0 ? void 0 : _a.map(header => ({
                    name: header.key,
                    value: header.value,
                })),
                body: this.importBody(request.body),
                authentication: this.importAuthentication(request.auth),
            };
        };
        this.importFolderItem = ({ name, description }, parentId) => {
            return {
                parentId,
                _id: `__GRP_${requestGroupCount++}__`,
                _type: 'request_group',
                name,
                description: description || '',
            };
        };
        this.importCollection = () => {
            const { item, info: { name, description }, variable, } = this.collection;
            const postmanVariable = this.importVariable(variable || []);
            const collectionFolder = {
                parentId: '__WORKSPACE_ID__',
                _id: `__GRP_${requestGroupCount++}__`,
                _type: 'request_group',
                name,
                description: typeof description === 'string' ? description : '',
            };
            if (postmanVariable) {
                collectionFolder.variable = postmanVariable;
            }
            return [collectionFolder, ...this.importItems(item, collectionFolder._id)];
        };
        this.importUrl = (url) => {
            if (!url) {
                return '';
            }
            if (typeof url === 'object' && url.raw) {
                return url.raw;
            }
            if (typeof url === 'string') {
                return url;
            }
            return '';
        };
        this.importBody = (body) => {
            if (!body) {
                return {};
            }
            switch (body.mode) {
                case 'raw':
                    return this.importBodyRaw(body.raw);
                case 'urlencoded':
                    return this.importBodyFormUrlEncoded(body.urlencoded);
                case 'formdata':
                    // TODO: Handle this as properly as multipart/form-data
                    return this.importBodyFormdata(body.formdata);
                default:
                    return {};
            }
        };
        this.importBodyFormdata = (formdata) => {
            const { schema } = this.collection.info;
            const params = formdata === null || formdata === void 0 ? void 0 : formdata.map(({ key, value, type, enabled, disabled, src }) => {
                const item = {
                    type,
                    name: key,
                };
                if (schema === POSTMAN_SCHEMA_V2_0) {
                    item.disabled = !enabled;
                }
                else if (schema === POSTMAN_SCHEMA_V2_1) {
                    item.disabled = !!disabled;
                }
                if (type === 'file') {
                    item.fileName = src;
                }
                else {
                    item.value = value;
                }
                return item;
            });
            return {
                params,
                mimeType: 'multipart/form-data',
            };
        };
        this.importBodyFormUrlEncoded = (urlEncoded) => {
            const { schema } = this.collection.info;
            const params = urlEncoded === null || urlEncoded === void 0 ? void 0 : urlEncoded.map(({ key, value, enabled, disabled }) => {
                const item = {
                    value,
                    name: key,
                };
                if (schema === POSTMAN_SCHEMA_V2_0) {
                    item.disabled = !enabled;
                }
                else if (schema === POSTMAN_SCHEMA_V2_1) {
                    item.disabled = !!disabled;
                }
                return item;
            });
            return {
                params,
                mimeType: 'application/x-www-form-urlencoded',
            };
        };
        this.importBodyRaw = (raw) => {
            if (raw === '') {
                return {};
            }
            return {
                mimeType: '',
                text: raw,
            };
        };
        this.importAuthentication = (auth) => {
            if (!auth) {
                return {};
            }
            switch (auth.type) {
                case 'awsv4':
                    return this.importAwsV4Authentication(auth);
                case 'basic':
                    return this.importBasicAuthentication(auth);
                case 'bearer':
                    return this.importBearerTokenAuthentication(auth);
                case 'digest':
                    return this.importDigestAuthentication(auth);
                case 'oauth1':
                    return this.importOauth1Authentication(auth);
                case 'oauth2':
                    return this.importOauth2Authentication(auth);
                default:
                    return {};
            }
        };
        this.importAwsV4Authentication = (auth) => {
            if (!auth.awsv4) {
                return {};
            }
            const item = {
                type: 'iam',
                disabled: false,
                accessKeyId: 'aws-access-key',
                region: 'aws-region',
                secretAccessKey: 'aws-secret-key',
                service: 'aws-service-name',
                sessionToken: 'aws-session-token',
            };
            const { schema } = this.collection.info;
            if (schema === POSTMAN_SCHEMA_V2_0) {
                const awsv4 = auth.awsv4;
                item.accessKeyId = awsv4 === null || awsv4 === void 0 ? void 0 : awsv4.accessKey;
                item.region = awsv4 === null || awsv4 === void 0 ? void 0 : awsv4.region;
                item.secretAccessKey = awsv4 === null || awsv4 === void 0 ? void 0 : awsv4.secretKey;
                item.service = awsv4 === null || awsv4 === void 0 ? void 0 : awsv4.service;
                item.sessionToken = awsv4 === null || awsv4 === void 0 ? void 0 : awsv4.sessionToken;
            }
            if (schema === POSTMAN_SCHEMA_V2_1) {
                const awsv4 = auth.awsv4;
                item.accessKeyId = this.findValueByKey(awsv4, 'accessKey');
                item.region = this.findValueByKey(awsv4, 'region');
                item.secretAccessKey = this.findValueByKey(awsv4, 'secretKey');
                item.service = this.findValueByKey(awsv4, 'service');
                item.sessionToken = this.findValueByKey(awsv4, 'sessionToken');
            }
            return item;
        };
        this.importBasicAuthentication = (auth) => {
            if (!auth.basic) {
                return {};
            }
            const item = {
                type: 'basic',
                disabled: false,
                username: '',
                password: '',
            };
            const { schema } = this.collection.info;
            if (schema === POSTMAN_SCHEMA_V2_0) {
                const basic = auth.basic;
                item.username = basic === null || basic === void 0 ? void 0 : basic.username;
                item.password = basic === null || basic === void 0 ? void 0 : basic.password;
            }
            if (schema === POSTMAN_SCHEMA_V2_1) {
                const basic = auth.basic;
                item.username = this.findValueByKey(basic, 'username');
                item.password = this.findValueByKey(basic, 'password');
            }
            return item;
        };
        this.importBearerTokenAuthentication = (auth) => {
            var _a;
            if (!auth.bearer) {
                return {};
            }
            const item = {
                type: 'bearer',
                disabled: false,
                token: '',
                prefix: '',
            };
            const { schema } = this.collection.info;
            if (schema === POSTMAN_SCHEMA_V2_0) {
                item.token = (_a = auth.bearer) === null || _a === void 0 ? void 0 : _a.token;
            }
            if (schema === POSTMAN_SCHEMA_V2_1) {
                item.token = this.findValueByKey(auth.bearer, 'token');
            }
            return item;
        };
        this.importDigestAuthentication = (auth) => {
            if (!auth.digest) {
                return {};
            }
            const item = {
                type: 'digest',
                disabled: false,
                username: '',
                password: '',
            };
            const { schema } = this.collection.info;
            if (schema === POSTMAN_SCHEMA_V2_0) {
                const digest = auth.digest;
                item.username = digest === null || digest === void 0 ? void 0 : digest.username;
                item.password = digest === null || digest === void 0 ? void 0 : digest.password;
            }
            if (schema === POSTMAN_SCHEMA_V2_1) {
                const digest = auth.digest;
                item.username = this.findValueByKey(digest, 'username');
                item.password = this.findValueByKey(digest, 'password');
            }
            return item;
        };
        this.importOauth1Authentication = (auth) => {
            if (!auth.oauth1) {
                return {};
            }
            const item = {
                type: 'oauth1',
                disabled: false,
                callback: '',
                consumerKey: '',
                consumerSecret: '',
                nonce: '',
                privateKey: '',
                realm: '',
                signatureMethod: '',
                timestamp: '',
                tokenKey: '',
                tokenSecret: '',
                verifier: '',
                version: '',
            };
            const { schema } = this.collection.info;
            if (schema === POSTMAN_SCHEMA_V2_0) {
                const oauth1 = auth.oauth1;
                item.consumerKey = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.consumerKey;
                item.consumerSecret = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.consumerSecret;
                item.nonce = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.nonce;
                item.realm = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.realm;
                item.signatureMethod = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.signatureMethod;
                item.timestamp = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.timestamp;
                item.tokenKey = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.token;
                item.tokenSecret = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.tokenSecret;
                item.version = oauth1 === null || oauth1 === void 0 ? void 0 : oauth1.version;
            }
            if (schema === POSTMAN_SCHEMA_V2_1) {
                const oauth1 = auth.oauth1;
                item.consumerKey = this.findValueByKey(oauth1, 'consumerKey');
                item.consumerSecret = this.findValueByKey(oauth1, 'consumerSecret');
                item.nonce = this.findValueByKey(oauth1, 'nonce');
                item.realm = this.findValueByKey(oauth1, 'realm');
                item.signatureMethod = this.findValueByKey(oauth1, 'signatureMethod');
                item.timestamp = this.findValueByKey(oauth1, 'timestamp');
                item.tokenKey = this.findValueByKey(oauth1, 'token');
                item.tokenSecret = this.findValueByKey(oauth1, 'tokenSecret');
                item.version = this.findValueByKey(oauth1, 'version');
            }
            return item;
        };
        this.importOauth2Authentication = (auth) => {
            if (!auth.oauth2) {
                return {};
            } // Note: Postman v2.0 and v2.1 don't export any Oauth config. They only export the token
            // So just return a disabled and empty Oauth 2 configuration so the user can fill it in later.
            const item = {
                type: 'oauth2',
                disabled: true,
                accessTokenUrl: '',
                authorizationUrl: '',
                grantType: 'authorization_code',
                password: '',
                username: '',
            };
            return item;
        };
        this.findValueByKey = (array, key) => {
            if (!array) {
                return '';
            }
            const obj = array.find(o => o.key === key);
            if (obj && typeof obj.value === 'string') {
                return obj.value || '';
            }
            return '';
        };
        this.collection = collection;
    }
}
const convert = rawData => {
    requestCount = 1;
    requestGroupCount = 1;
    try {
        const collection = JSON.parse(rawData);
        if (collection.info.schema === POSTMAN_SCHEMA_V2_0 ||
            collection.info.schema === POSTMAN_SCHEMA_V2_1) {
            return new ImportCollection(collection).importCollection();
        }
    }
    catch (e) {
        // Nothing
    }
    return null;
};
exports.convert = convert;
//# sourceMappingURL=postman.js.map