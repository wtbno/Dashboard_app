"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = exports.description = exports.name = exports.id = void 0;
exports.id = 'insomnia-1';
exports.name = 'Insomnia v1';
exports.description = 'Legacy Insomnia format';
let requestCount = 1;
let requestGroupCount = 1;
const FORMAT_MAP = {
    form: 'application/x-www-form-urlencoded',
    json: 'application/json',
    text: 'text/plain',
    xml: 'application/xml',
};
const importRequestGroupItem = (item) => {
    var _a, _b;
    const environment = (_b = (_a = item.environments) === null || _a === void 0 ? void 0 : _a.base) !== null && _b !== void 0 ? _b : {};
    const count = requestGroupCount++;
    return {
        _type: 'request_group',
        _id: `__GRP_${count}__`,
        parentId: '__WORKSPACE_ID__',
        environment,
        name: item.name || `Imported Folder ${count}`,
    };
};
const importRequestItem = (parentId) => ({ authentication: { username, password } = {}, headers = [], __insomnia, body: itemBody, name, url = '', method = 'GET', params = [], }) => {
    let contentTypeHeader = headers.find(({ name }) => name.toLowerCase() === 'content-type');
    if (__insomnia === null || __insomnia === void 0 ? void 0 : __insomnia.format) {
        const contentType = FORMAT_MAP[__insomnia.format];
        if (!contentTypeHeader) {
            contentTypeHeader = {
                name: 'Content-Type',
                value: contentType,
            };
            headers.push(contentTypeHeader);
        }
    }
    let body = {};
    const isForm = contentTypeHeader &&
        (contentTypeHeader.value.match(/^application\/x-www-form-urlencoded/i) ||
            contentTypeHeader.value.match(/^multipart\/form-encoded/i));
    if (isForm) {
        const mimeType = contentTypeHeader ? contentTypeHeader.value.split(';')[0] : '';
        const params = (typeof itemBody === 'string' ? itemBody : '')
            .split('&')
            .map(param => {
            const [name, value] = param.split('=');
            return {
                name: decodeURIComponent(name),
                value: decodeURIComponent(value || ''),
            };
        });
        body = {
            mimeType,
            params,
        };
    }
    else if (itemBody) {
        const mimeType = (__insomnia === null || __insomnia === void 0 ? void 0 : __insomnia.format) ? FORMAT_MAP[__insomnia === null || __insomnia === void 0 ? void 0 : __insomnia.format] : '';
        body = {
            mimeType,
            text: itemBody,
        };
    }
    const count = requestCount++;
    return {
        _type: 'request',
        _id: `__REQ_${count}__`,
        parentId,
        name: name || `Imported HAR ${count}`,
        url,
        method,
        body,
        parameters: params || [],
        headers,
        authentication: {
            password,
            username,
        },
    };
};
const convert = rawData => {
    requestCount = 1;
    requestGroupCount = 1;
    let data;
    try {
        data = JSON.parse(rawData);
    }
    catch (error) {
        return null;
    }
    if (data.__export_format !== 1) {
        // Exit early if it's not the legacy format
        return null;
    }
    return data.items
        .map(item => {
        const requestGroup = importRequestGroupItem(item);
        return [
            requestGroup,
            ...item.requests.map(importRequestItem(requestGroup._id)),
        ];
    })
        .flat();
};
exports.convert = convert;
//# sourceMappingURL=insomnia-1.js.map