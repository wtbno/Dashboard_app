/**
 * This file has been extracted and modified from Swagger UI.
 *
 * @license Apache 2.0
 * @see {@link https://github.com/swagger-api/swagger-ui/blob/master/src/core/plugins/samples/fn.js}
 */
var _a = require('./utils'), objectify = _a.objectify, usesPolymorphism = _a.usesPolymorphism, isFunc = _a.isFunc, normalizeArray = _a.normalizeArray, deeplyStripKey = _a.deeplyStripKey;
var memoize = require('memoizee');
var mergeAllOf = require('json-schema-merge-allof');
var primitives = {
    string: function () { return 'string'; },
    string_email: function () { return 'user@example.com'; },
    'string_date-time': function () { return new Date().toISOString(); },
    string_date: function () { return new Date().toISOString().substring(0, 10); },
    'string_YYYY-MM-DD': function () { return new Date().toISOString().substring(0, 10); },
    string_uuid: function () { return '3fa85f64-5717-4562-b3fc-2c963f66afa6'; },
    string_hostname: function () { return 'example.com'; },
    string_ipv4: function () { return '198.51.100.42'; },
    string_ipv6: function () { return '2001:0db8:5b96:0000:0000:426f:8e17:642a'; },
    number: function () { return 0; },
    number_float: function () { return 0.0; },
    integer: function () { return 0; },
    boolean: function (schema) { return (typeof schema["default"] === 'boolean' ? schema["default"] : true); }
};
var primitive = function (schema) {
    schema = objectify(schema);
    var type = schema.type, format = schema.format;
    var fn = primitives[type + "_" + format] || primitives[type];
    if (isFunc(fn)) {
        return fn(schema);
    }
    return "Unknown Type: " + schema.type;
};
var sampleFromSchema = function (schema, config) {
    if (config === void 0) { config = {}; }
    var objectifySchema = objectify(schema);
    var type = objectifySchema.type;
    var hasPolymorphism = usesPolymorphism(objectifySchema);
    if (hasPolymorphism === 'allOf') {
        try {
            return sampleFromSchema(mergeAllOf(objectifySchema, {
                resolvers: {
                    // Ignore any unrecognized OAS-specific keywords that might be present on the schema (like `xml`).
                    defaultResolver: mergeAllOf.options.resolvers.title
                }
            }), config);
        }
        catch (error) {
            return undefined;
        }
    }
    else if (hasPolymorphism) {
        return sampleFromSchema(objectifySchema[hasPolymorphism][0], config);
    }
    var example = objectifySchema.example, additionalProperties = objectifySchema.additionalProperties, properties = objectifySchema.properties, items = objectifySchema.items;
    var includeReadOnly = config.includeReadOnly, includeWriteOnly = config.includeWriteOnly;
    if (example !== undefined) {
        return deeplyStripKey(example, '$$ref', function (val) {
            // do a couple of quick sanity tests to ensure the value
            // looks like a $$ref that swagger-client generates.
            return typeof val === 'string' && val.indexOf('#') > -1;
        });
    }
    if (!type) {
        if (properties || additionalProperties) {
            type = 'object';
        }
        else if (items) {
            type = 'array';
        }
        else {
            return undefined;
        }
    }
    if (type === 'object') {
        var props = objectify(properties);
        var obj = {};
        // eslint-disable-next-line no-restricted-syntax
        for (var name_1 in props) {
            if (props[name_1] && props[name_1].deprecated) {
                // eslint-disable-next-line no-continue
                continue;
            }
            if (props[name_1] && props[name_1].readOnly && !includeReadOnly) {
                // eslint-disable-next-line no-continue
                continue;
            }
            if (props[name_1] && props[name_1].writeOnly && !includeWriteOnly) {
                // eslint-disable-next-line no-continue
                continue;
            }
            obj[name_1] = sampleFromSchema(props[name_1], config);
        }
        if (additionalProperties === true) {
            obj.additionalProp = {};
        }
        else if (additionalProperties) {
            var additionalProps = objectify(additionalProperties);
            var additionalPropVal = sampleFromSchema(additionalProps, config);
            obj.additionalProp = additionalPropVal;
        }
        return obj;
    }
    if (type === 'array') {
        // `items` should always be present on arrays, but if it isn't we should at least do our best to support its
        // absence.
        if (typeof items === 'undefined') {
            return [];
        }
        if (Array.isArray(items.anyOf)) {
            return items.anyOf.map(function (i) { return sampleFromSchema(i, config); });
        }
        if (Array.isArray(items.oneOf)) {
            return items.oneOf.map(function (i) { return sampleFromSchema(i, config); });
        }
        return [sampleFromSchema(items, config)];
    }
    if (schema["enum"]) {
        if (schema["default"]) {
            return schema["default"];
        }
        return normalizeArray(schema["enum"])[0];
    }
    if (type === 'file') {
        return undefined;
    }
    return primitive(schema);
};
module.exports.sampleFromSchema = memoize(sampleFromSchema);
