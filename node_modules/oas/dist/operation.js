var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var findSchemaDefinition = require('./lib/find-schema-definition')["default"];
var getParametersAsJsonSchema = require('./operation/get-parameters-as-json-schema');
var getResponseAsJsonSchema = require('./operation/get-response-as-json-schema');
var getRequestBodyExamples = require('./operation/get-requestbody-examples');
var getCallbackExamples = require('./operation/get-callback-examples');
var getResponseExamples = require('./operation/get-response-examples');
var matchesMimeType = require('./lib/matches-mimetype');
var Operation = /** @class */ (function () {
    function Operation(oas, path, method, operation) {
        this.schema = operation;
        this.oas = oas;
        this.path = path;
        this.method = method;
        this.contentType = undefined;
        this.requestBodyExamples = undefined;
        this.responseExamples = undefined;
        this.callbackExamples = undefined;
    }
    Operation.prototype.getContentType = function () {
        var _this = this;
        if (this.contentType) {
            return this.contentType;
        }
        var types = [];
        if (this.schema.requestBody) {
            if ('$ref' in this.schema.requestBody) {
                this.schema.requestBody = findSchemaDefinition(this.schema.requestBody.$ref, this.oas);
            }
            if ('content' in this.schema.requestBody) {
                types = Object.keys(this.schema.requestBody.content);
            }
        }
        this.contentType = 'application/json';
        if (types && types.length) {
            this.contentType = types[0];
        }
        // Favor JSON if it exists
        types.forEach(function (t) {
            if (t.match(/json/)) {
                _this.contentType = t;
            }
        });
        return this.contentType;
    };
    Operation.prototype.isFormUrlEncoded = function () {
        return matchesMimeType.formUrlEncoded(this.getContentType());
    };
    Operation.prototype.isMultipart = function () {
        return matchesMimeType.multipart(this.getContentType());
    };
    Operation.prototype.isJson = function () {
        return matchesMimeType.json(this.getContentType());
    };
    Operation.prototype.isXml = function () {
        return matchesMimeType.xml(this.getContentType());
    };
    /**
     * Returns an array of all security requirements associated wtih this operation. If none are defined at the operation
     * level, the securities for the entire API definition are returned (with an empty array as a final fallback).
     *
     * @returns {array}
     */
    Operation.prototype.getSecurity = function () {
        if (!('components' in this.oas) || !('securitySchemes' in this.oas.components)) {
            return [];
        }
        return this.schema.security || this.oas.security || [];
    };
    /**
     * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
     * @param {boolean} filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent security
     *    schemes, rather than returning `false`.
     * @returns {array} An array of arrays of objects of grouped security schemes. The inner array determines and-grouped
     *    security schemes, the outer array determines or-groups.
     */
    Operation.prototype.getSecurityWithTypes = function (filterInvalid) {
        var _this = this;
        if (filterInvalid === void 0) { filterInvalid = false; }
        var securityRequirements = this.getSecurity();
        return securityRequirements.map(function (requirement) {
            var keys;
            try {
                keys = Object.keys(requirement);
            }
            catch (e) {
                return false;
            }
            var keysWithTypes = keys.map(function (key) {
                var security;
                try {
                    security = _this.oas.components.securitySchemes[key];
                }
                catch (e) {
                    return false;
                }
                if (!security)
                    return false;
                var type = security.type;
                if (security.type === 'http') {
                    if (security.scheme === 'basic')
                        type = 'Basic';
                    if (security.scheme === 'bearer')
                        type = 'Bearer';
                }
                else if (security.type === 'oauth2') {
                    type = 'OAuth2';
                }
                else if (security.type === 'apiKey') {
                    if (security["in"] === 'query')
                        type = 'Query';
                    else if (security["in"] === 'header')
                        type = 'Header';
                    else if (security["in"] === 'cookie')
                        type = 'Cookie';
                }
                else {
                    return false;
                }
                security._key = key;
                return { type: type, security: security };
            });
            if (filterInvalid)
                return keysWithTypes.filter(function (key) { return key !== false; });
            return keysWithTypes;
        });
    };
    /**
     * @returns An object where the keys are unique scheme types,
     * and the values are arrays containing each security scheme of that type.
     */
    Operation.prototype.prepareSecurity = function () {
        var securitiesWithTypes = this.getSecurityWithTypes();
        return securitiesWithTypes.reduce(function (prev, securities) {
            securities.forEach(function (security) {
                // Remove non-existent schemes
                if (!security)
                    return;
                if (!prev[security.type])
                    prev[security.type] = [];
                // Only add schemes we haven't seen yet.
                var exists = prev[security.type].findIndex(function (sec) { return sec._key === security.security._key; });
                if (exists < 0) {
                    prev[security.type].push(security.security);
                }
            });
            return prev;
        }, {});
    };
    Operation.prototype.getHeaders = function () {
        var _this = this;
        this.headers = {
            request: [],
            response: []
        };
        var security = this.prepareSecurity();
        if (security.Header) {
            this.headers.request = security.Header.map(function (h) {
                return h.name;
            });
        }
        if (security.Bearer || security.Basic) {
            this.headers.request.push('Authorization');
        }
        if (security.Cookie) {
            this.headers.request.push('Cookie');
        }
        if (this.schema.parameters) {
            this.headers.request = this.headers.request.concat(this.schema.parameters
                .map(function (p) {
                if (p["in"] && p["in"] === 'header')
                    return p.name;
                if (p.$ref) {
                    var name_1 = findSchemaDefinition(p.$ref, _this.oas).name;
                    return name_1;
                }
                return undefined;
            })
                .filter(function (p) { return p; }));
        }
        this.headers.response = Object.keys(this.schema.responses)
            .filter(function (r) { return _this.schema.responses[r].headers; })
            .map(function (r) { return Object.keys(_this.schema.responses[r].headers); })
            .reduce(function (a, b) { return a.concat(b); }, []);
        // If the operation doesn't already specify a 'content-type' request header,
        // we check if the path operation request body contains content, which implies that
        // we should also include the 'content-type' header.
        if (!this.headers.request.includes('Content-Type') && this.schema.requestBody) {
            if (this.schema.requestBody.$ref) {
                var ref = findSchemaDefinition(this.schema.requestBody.$ref, this.oas);
                if (ref.content && Object.keys(ref.content)) {
                    this.headers.request.push('Content-Type');
                }
            }
            else if (this.schema.requestBody.content && Object.keys(this.schema.requestBody.content))
                this.headers.request.push('Content-Type');
        }
        // This is a similar approach, but in this case if we check the response content
        // and prioritize the 'accept' request header and 'content-type' request header
        if (this.schema.responses) {
            if (Object.keys(this.schema.responses).some(function (response) { return !!_this.schema.responses[response].content; })) {
                if (!this.headers.request.includes('Accept'))
                    this.headers.request.push('Accept');
                if (!this.headers.response.includes('Content-Type'))
                    this.headers.response.push('Content-Type');
            }
        }
        return this.headers;
    };
    /**
     * Determine if the operation has an operation present in its schema.
     *
     * @return {boolean}
     */
    Operation.prototype.hasOperationId = function () {
        return 'operationId' in this.schema;
    };
    /**
     * Get an `operationId` for this operation. If one is not present (it's not required by the spec!) a hash of the path
     * and method will be returned instead.
     *
     * @return {string}
     */
    Operation.prototype.getOperationId = function () {
        if ('operationId' in this.schema) {
            return this.schema.operationId;
        }
        var url = this.path
            .replace(/[^a-zA-Z0-9]/g, '-') // Remove weird characters
            .replace(/^-|-$/g, '') // Don't start or end with -
            .replace(/--+/g, '-') // Remove double --'s
            .toLowerCase();
        return this.method.toLowerCase() + "_" + url;
    };
    /**
     * Return an array of all tags, and their metadata, that exist on this operation.
     *
     * @returns {array}
     */
    Operation.prototype.getTags = function () {
        if (!('tags' in this.schema)) {
            return [];
        }
        var oasTags = new Map();
        if ('tags' in this.oas) {
            this.oas.tags.forEach(function (tag) {
                oasTags.set(tag.name, tag);
            });
        }
        oasTags = Object.fromEntries(oasTags);
        var tags = [];
        if (Array.isArray(this.schema.tags)) {
            this.schema.tags.forEach(function (tag) {
                if (tag in oasTags) {
                    tags.push(oasTags[tag]);
                }
                else {
                    tags.push({
                        name: tag
                    });
                }
            });
        }
        return tags;
    };
    /**
     * Return is the operation is flagged as `deprecated` or not.
     *
     * @returns {boolean}
     */
    Operation.prototype.isDeprecated = function () {
        return 'deprecated' in this.schema ? this.schema.deprecated : false;
    };
    /**
     * Return the parameters (non-request body) on the operation.
     *
     * @todo This should also pull in common params.
     * @return {array}
     */
    Operation.prototype.getParameters = function () {
        return 'parameters' in this.schema ? this.schema.parameters : [];
    };
    /**
     * Convert the operation into an array of JSON Schema for each available type of parameter available on the operation.
     * `globalDefaults` contains an object of user defined parameter defaults used in constructSchema
     *
     * @param {Object} globalDefaults
     * @return {array}
     */
    Operation.prototype.getParametersAsJsonSchema = function (globalDefaults) {
        return getParametersAsJsonSchema(this.path, this.schema, this.oas, globalDefaults);
    };
    /**
     * Get a single response for this status code, formatted as JSON schema
     * @param {*} statusCode
     * @returns
     */
    Operation.prototype.getResponseAsJsonSchema = function (statusCode) {
        return getResponseAsJsonSchema(this, this.oas, statusCode);
    };
    /**
     * Get an array of all valid response status codes for this operation
     * @param {*} statusCode
     * @returns
     */
    Operation.prototype.getResponseStatusCodes = function () {
        return this.schema.responses ? Object.keys(this.schema.responses) : [];
    };
    /**
     * Determine if the operation has a request body.
     *
     * @return {boolean}
     */
    Operation.prototype.hasRequestBody = function () {
        return !!this.schema.requestBody;
    };
    /**
     * Retrieve an array of request body examples that this operation has.
     *
     * @returns {array}
     */
    Operation.prototype.getRequestBodyExamples = function () {
        if (this.requestBodyExamples) {
            return this.requestBodyExamples;
        }
        this.requestBodyExamples = getRequestBodyExamples(this.schema);
        return this.requestBodyExamples;
    };
    /**
     * Return a specific response out of the operation by a given HTTP status code.
     *
     * @param {integer} statusCode
     * @return {(boolean|object)}
     */
    Operation.prototype.getResponseByStatusCode = function (statusCode) {
        if (!this.schema.responses) {
            return false;
        }
        if (typeof this.schema.responses[statusCode] === 'undefined') {
            return false;
        }
        return this.schema.responses[statusCode];
    };
    /**
     * Retrieve an array of response examples that this operation has.
     *
     * @returns {array}
     */
    Operation.prototype.getResponseExamples = function () {
        if (this.responseExamples) {
            return this.responseExamples;
        }
        this.responseExamples = getResponseExamples(this.schema);
        return this.responseExamples;
    };
    /**
     * Determine if the operation has callbacks.
     *
     * @return {boolean}
     */
    Operation.prototype.hasCallbacks = function () {
        return !!this.schema.callbacks;
    };
    /**
     * Retrieve a specific callback
     *
     * @returns {Operation}
     */
    Operation.prototype.getCallback = function (identifier, expression, method) {
        if (!this.schema.callbacks)
            return false;
        var callback = this.schema.callbacks[identifier] ? this.schema.callbacks[identifier][expression] : false;
        if (!callback || !callback[method])
            return false;
        // eslint-disable-next-line no-use-before-define
        return new Callback(this.oas, expression, method, callback[method], identifier);
    };
    /**
     * Retrieve an array of operations created from each callback.
     *
     * @returns {array}
     */
    Operation.prototype.getCallbacks = function () {
        var _this = this;
        var callbackOperations = [];
        if (!this.hasCallbacks())
            return false;
        Object.keys(this.schema.callbacks).forEach(function (callback) {
            Object.keys(_this.schema.callbacks[callback]).forEach(function (expression) {
                Object.keys(_this.schema.callbacks[callback][expression]).forEach(function (method) {
                    callbackOperations.push(_this.getCallback(callback, expression, method));
                });
            });
        });
        return callbackOperations;
    };
    /**
     * Retrieve an array of callback examples that this operation has.
     *
     * @returns {array}
     */
    Operation.prototype.getCallbackExamples = function () {
        if (this.callbackExamples) {
            return this.callbackExamples;
        }
        this.callbackExamples = getCallbackExamples(this.schema);
        return this.callbackExamples;
    };
    return Operation;
}());
var Callback = /** @class */ (function (_super) {
    __extends(Callback, _super);
    function Callback(oas, path, method, operation, identifier) {
        var _this = _super.call(this, oas, path, method, operation) || this;
        _this.identifier = identifier;
        return _this;
    }
    /**
     * Return the primary identifier for this callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     *
     * @returns {string}
     */
    Callback.prototype.getIdentifier = function () {
        return this.identifier;
    };
    return Callback;
}(Operation));
var Webhook = /** @class */ (function (_super) {
    __extends(Webhook, _super);
    function Webhook() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Webhook;
}(Operation));
module.exports = Operation;
module.exports.Callback = Callback;
module.exports.Webhook = Webhook;
