var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var $RefParser = require('@apidevtools/json-schema-ref-parser');
var _a = require('path-to-regexp'), pathToRegexp = _a.pathToRegexp, match = _a.match;
var getAuth = require('./lib/get-auth')["default"];
var getUserVariable = require('./lib/get-user-variable');
var Operation = require('./operation');
var _b = require('./operation'), Callback = _b.Callback, Webhook = _b.Webhook;
var utils = require('./utils')["default"];
function ensureProtocol(url) {
    // Add protocol to urls starting with // e.g. //example.com
    // This is because httpsnippet throws a HARError when it doesnt have a protocol
    if (url.match(/^\/\//)) {
        return "https:" + url;
    }
    // Add protocol to urls with no // within them
    // This is because httpsnippet throws a HARError when it doesnt have a protocol
    if (!url.match(/\/\//)) {
        return "https://" + url;
    }
    return url;
}
function stripTrailingSlash(url) {
    if (url[url.length - 1] === '/') {
        return url.slice(0, -1);
    }
    return url;
}
function normalizedUrl(oas, selected) {
    var exampleDotCom = 'https://example.com';
    var url;
    try {
        url = oas.servers[selected].url;
        // This is to catch the case where servers = [{}]
        if (!url)
            throw new Error('no url');
        // Stripping the '/' off the end
        url = stripTrailingSlash(url);
        // RM-1044 Check if the URL is just a path a missing an origin, for example `/api/v3`
        // If so, then make example.com the origin to avoid it becoming something invalid like https:///api/v3
        if (url.startsWith('/') && !url.startsWith('//')) {
            var urlWithOrigin = new URL(exampleDotCom);
            urlWithOrigin.pathname = url;
            url = urlWithOrigin.href;
        }
    }
    catch (e) {
        url = exampleDotCom;
    }
    return ensureProtocol(url);
}
/**
 * With a URL that may contain server variables, transform those server variables into regex that we can query against.
 *
 * For example, when given `https://{region}.node.example.com/v14` this will return back:
 *
 *    https://([-_a-zA-Z0-9[\\]]+).node.example.com/v14
 *
 * @param {String} url
 * @returns {String}
 */
function transformUrlIntoRegex(url) {
    return stripTrailingSlash(url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, '([-_a-zA-Z0-9[\\]]+)'));
}
function normalizePath(path) {
    // In addition to transforming `{pathParam}` into `:pathParam` we also need to escape cases where a non-variabled
    // colon is next to a variabled-colon because if we don't `path-to-regexp` won't be able to correct identify where the
    // variable starts.
    //
    // For example if the URL is `/post/:param1::param2` we'll be escaping it to `/post/:param1\::param2`.
    return (path
        .replace(/{(.*?)}/g, ':$1')
        .replace(/::/, '\\::')
        // Need to escape question marks too because they're treated as regex modifiers in `path-to-regexp`
        .split('?')[0]);
}
function generatePathMatches(paths, pathName, origin) {
    var prunedPathName = pathName.split('?')[0];
    return Object.keys(paths)
        .map(function (path) {
        var cleanedPath = normalizePath(path);
        var matchStatement = match(cleanedPath, { decode: decodeURIComponent });
        var matchResult = matchStatement(prunedPathName);
        var slugs = {};
        if (matchResult && Object.keys(matchResult.params).length) {
            Object.keys(matchResult.params).forEach(function (param) {
                slugs[":" + param] = matchResult.params[param];
            });
        }
        return {
            url: {
                origin: origin,
                path: cleanedPath.replace(/\\::/, '::'),
                nonNormalizedPath: path,
                slugs: slugs
            },
            operation: paths[path],
            match: matchResult
        };
    })
        .filter(function (p) { return p.match; });
}
function filterPathMethods(pathMatches, targetMethod) {
    var regExp = pathToRegexp(targetMethod);
    return pathMatches
        .map(function (p) {
        var captures = Object.keys(p.operation).filter(function (r) { return regExp.exec(r); });
        if (captures.length) {
            var method = captures[0];
            p.url.method = method.toUpperCase();
            return {
                url: p.url,
                operation: p.operation[method]
            };
        }
        return undefined;
    })
        .filter(function (p) { return p; });
}
function findTargetPath(pathMatches) {
    var minCount = Object.keys(pathMatches[0].url.slugs).length;
    var operation;
    for (var m = 0; m < pathMatches.length; m += 1) {
        var selection = pathMatches[m];
        var paramCount = Object.keys(selection.url.slugs).length;
        if (paramCount <= minCount) {
            minCount = paramCount;
            operation = selection;
        }
    }
    return operation;
}
var Oas = /** @class */ (function () {
    function Oas(oas, user) {
        Object.assign(this, oas);
        this.user = user || {};
        this._promises = [];
        this._dereferencing = {
            processing: false,
            complete: false
        };
    }
    Oas.prototype.getVersion = function () {
        if (this.swagger) {
            return this.swagger;
        }
        else if (this.openapi) {
            return this.openapi;
        }
        throw new Error('Unable to recognize what specification version this API definition conforms to.');
    };
    Oas.prototype.url = function (selected, variables) {
        if (selected === void 0) { selected = 0; }
        var url = normalizedUrl(this, selected);
        return this.replaceUrl(url, variables || this.variables(selected)).trim();
    };
    Oas.prototype.variables = function (selected) {
        if (selected === void 0) { selected = 0; }
        var variables;
        try {
            variables = this.servers[selected].variables;
            if (!variables)
                throw new Error('no variables');
        }
        catch (e) {
            variables = {};
        }
        return variables;
    };
    Oas.prototype.defaultVariables = function (selected) {
        var _this = this;
        if (selected === void 0) { selected = 0; }
        var variables = this.variables(selected);
        var defaults = {};
        Object.keys(variables).forEach(function (key) {
            defaults[key] = getUserVariable(_this.user, key) || variables[key]["default"] || '';
        });
        return defaults;
    };
    Oas.prototype.splitUrl = function (selected) {
        if (selected === void 0) { selected = 0; }
        var url = normalizedUrl(this, selected);
        var variables = this.variables(selected);
        return url
            .split(/({.+?})/)
            .filter(Boolean)
            .map(function (part, i) {
            var isVariable = part.match(/[{}]/);
            var value = part.replace(/[{}]/g, '');
            // To ensure unique keys, we're going to create a key
            // with the value concatenated to its index.
            var key = value + "-" + i;
            if (!isVariable) {
                return {
                    type: 'text',
                    value: value,
                    key: key
                };
            }
            // I wanted to do this here but due to us not
            // babelifying node_modules and not committing ./.tooling
            // to git, I'm just gunna do this for now so I can
            // get on with my life!
            //
            // const variable = variables?.[value]
            var variable = variables[value] || {};
            return {
                type: 'variable',
                value: value,
                key: key,
                description: variable.description,
                "enum": variable["enum"]
            };
        });
    };
    /**
     * With a fully composed server URL, run through our list of known OAS servers and return back which server URL was
     * selected along with any contained server variables split out.
     *
     * For example, if you have an OAS server URL of `https://{name}.example.com:{port}/{basePath}`, and pass in
     * `https://buster.example.com:3000/pet` to this function, you'll get back the following:
     *
     *    { selected: 0, variables: { name: 'buster', port: 3000, basePath: 'pet' } }
     *
     * Re-supplying this data to `oas.url()` should return the same URL you passed into this method.
     *
     * @param {String} baseUrl
     * @returns {Object|Boolean}
     */
    Oas.prototype.splitVariables = function (baseUrl) {
        var matchedServer = (this.servers || [])
            .map(function (server, i) {
            var rgx = transformUrlIntoRegex(server.url);
            var found = new RegExp(rgx).exec(baseUrl);
            if (!found) {
                return false;
            }
            // While it'd be nice to use named regex groups to extract path parameters from the URL and match them up with
            // the variables that we have present in it, JS unfortunately doesn't support having the groups duplicated. So
            // instead of doing that we need to re-regex the server URL, this time splitting on the path parameters -- this
            // way we'll be able to extract the parameter names and match them up with the matched server that we obtained
            // above.
            var variables = {};
            __spreadArray([], __read(server.url.matchAll(/{([-_a-zA-Z0-9[\]]+)}/g)), false).forEach(function (variable, y) {
                variables[variable[1]] = found[y + 1];
            });
            return {
                selected: i,
                variables: variables
            };
        })
            .filter(Boolean);
        return matchedServer.length ? matchedServer[0] : false;
    };
    /**
     * Replace templated variables with supplied data in a given URL.
     *
     * There are a couple ways that this will utilize variable data:
     *
     *  - If data is stored in `this.user` and it matches up with the variable name in the URL user data
     *    will always take priority. See `getUserVariable` for some more information on how this data is pulled from
     *    `this.user`.
     *  - Supplying a `variables` object. This incoming `variables` object can be two formats:
     *    `{ variableName: { default: 'value' } }` and `{ variableName: 'value' }`. If the former is present, that will
     *    take prescendence over the latter.
     *
     * If no variables supplied match up with the template name, the template name will instead be used as the variable
     * data.
     *
     * @param {String} url
     * @param {Object} variables
     * @returns String
     */
    Oas.prototype.replaceUrl = function (url, variables) {
        var _this = this;
        if (variables === void 0) { variables = {}; }
        // When we're constructing URLs, server URLs with trailing slashes cause problems with doing lookups, so if we have
        // one here on, slice it off.
        return stripTrailingSlash(url.replace(/{([-_a-zA-Z0-9[\]]+)}/g, function (original, key) {
            if (getUserVariable(_this.user, key)) {
                return getUserVariable(_this.user, key);
            }
            if (key in variables) {
                if (typeof variables[key] === 'object') {
                    if (!Array.isArray(variables[key]) && variables[key] !== null && 'default' in variables[key]) {
                        return variables[key]["default"];
                    }
                }
                else {
                    return variables[key];
                }
            }
            return original;
        }));
    };
    Oas.prototype.operation = function (path, method, opts) {
        if (opts === void 0) { opts = {}; }
        // If we're unable to locate an operation for this path+method combination within the API definition, we should
        // still set an empty schema on the operation in the `Operation` class because if we don't trying to use any of the
        // accessors on that class are going to fail as `schema` will be `undefined`.
        var operation = {
            parameters: []
        };
        if (opts.isWebhook) {
            if (this.webhooks && this.webhooks[path] && this.webhooks[path][method]) {
                operation = this.webhooks[path][method];
            }
            return new Webhook(this, path, method, operation);
        }
        if (this.paths && this.paths[path] && this.paths[path][method]) {
            operation = this.paths[path][method];
        }
        return new Operation(this, path, method, operation);
    };
    Oas.prototype.findOperationMatches = function (url) {
        var _a;
        var _this = this;
        var _b = new URL(url), origin = _b.origin, hostname = _b.hostname;
        var originRegExp = new RegExp(origin, 'i');
        var _c = this, servers = _c.servers, paths = _c.paths;
        var pathName;
        var targetServer;
        var matchedServer;
        if (!servers || !servers.length) {
            // If this API definition doesn't have any servers set up let's treat it as if it were https://example.com because
            // that's the default origin we add in `normalizedUrl` under the same circumstances. Without this we won't be able
            // to match paths within what is otherwise a valid OpenAPI definition.
            matchedServer = {
                url: 'https://example.com'
            };
        }
        else {
            matchedServer = servers.find(function (s) { return originRegExp.exec(_this.replaceUrl(s.url, s.variables || {})); });
            if (!matchedServer) {
                var hostnameRegExp_1 = new RegExp(hostname);
                matchedServer = servers.find(function (s) { return hostnameRegExp_1.exec(_this.replaceUrl(s.url, s.variables || {})); });
            }
        }
        // If we **still** haven't found a matching server, then the OAS server URL might have server variables and we
        // should loosen it up with regex to try to discover a matching path.
        //
        // For example if an OAS has `https://{region}.node.example.com/v14` set as its server URL, and the `this.user`
        // object has a `region` value of `us`, if we're trying to locate an operation for
        // https://eu.node.example.com/v14/api/esm we won't be able to because normally the users `region` of `us` will be
        // transposed in and we'll be trying to locate `eu.node.example.com` in `us.node.example.com` -- which won't work.
        //
        // So what this does is transform `https://{region}.node.example.com/v14` into
        // `https://([-_a-zA-Z0-9[\\]]+).node.example.com/v14`, and from there we'll be able to match
        // https://eu.node.example.com/v14/api/esm and ultimately find the operation matches for `/api/esm`.
        if (!matchedServer) {
            var matchedServerAndPath = servers
                .map(function (server) {
                var rgx = transformUrlIntoRegex(server.url);
                var found = new RegExp(rgx).exec(url);
                if (!found) {
                    return false;
                }
                return {
                    matchedServer: server,
                    pathName: url.split(new RegExp(rgx)).slice(-1).pop()
                };
            })
                .filter(Boolean);
            if (!matchedServerAndPath.length) {
                return undefined;
            }
            pathName = matchedServerAndPath[0].pathName;
            targetServer = __assign({}, matchedServerAndPath[0].matchedServer);
        }
        else {
            // Instead of setting `url` directly against `matchedServer` we need to set it to an intermediary object as
            // directly modifying `matchedServer.url` will in turn update `this.servers[idx].url` which we absolutely do not
            // want to happen.
            targetServer = __assign(__assign({}, matchedServer), { url: this.replaceUrl(matchedServer.url, matchedServer.variables || {}) });
            _a = __read(url.split(new RegExp(targetServer.url, 'i')), 2), pathName = _a[1];
        }
        if (pathName === undefined)
            return undefined;
        if (pathName === '')
            pathName = '/';
        var annotatedPaths = generatePathMatches(paths, pathName, targetServer.url);
        if (!annotatedPaths.length)
            return undefined;
        return annotatedPaths;
    };
    /**
     * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object containing a `url`
     * object and another one for `operation`. This differs from `getOperation()` in that it does not return an instance
     * of the `Operation` class.
     *
     * @param {String} url
     * @param {String} method
     * @return {(Object|undefined)}
     */
    Oas.prototype.findOperation = function (url, method) {
        var annotatedPaths = this.findOperationMatches(url);
        if (!annotatedPaths) {
            return undefined;
        }
        var includesMethod = filterPathMethods(annotatedPaths, method);
        if (!includesMethod.length)
            return undefined;
        return findTargetPath(includesMethod);
    };
    /**
     * Discover an operation in an OAS from a fully-formed URL without an HTTP method. Will return an object containing a `url`
     * object and another one for `operation`.
     *
     * @param {String} url
     * @return {(Object|undefined)}
     */
    Oas.prototype.findOperationWithoutMethod = function (url) {
        var annotatedPaths = this.findOperationMatches(url);
        if (!annotatedPaths) {
            return undefined;
        }
        return findTargetPath(annotatedPaths);
    };
    /**
     * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from `findOperation` in that while
     * this method will return an `Operation` instance, `findOperation()` does not.
     *
     * @param {String} url
     * @param {String} method
     * @return {(Operation|undefined)}
     */
    Oas.prototype.getOperation = function (url, method) {
        var op = this.findOperation(url, method);
        if (op === undefined) {
            return undefined;
        }
        return this.operation(op.url.nonNormalizedPath, method);
    };
    /**
     * With an object of user information, retrieve an appropriate API key from the current OAS definition.
     *
     * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}
     * @param {Object} user
     * @param {Boolean|String} selectedApp
     */
    Oas.prototype.getAuth = function (user, selectedApp) {
        if (selectedApp === void 0) { selectedApp = false; }
        if (Object.keys(this.components || {}).length === 0 ||
            Object.keys(this.components.securitySchemes || {}).length === 0) {
            return {};
        }
        return getAuth(this, user, selectedApp);
    };
    /**
     * Returns the `paths` object that exists in this API definition but with every `method` mapped to an instance of
     * the `Operation` class.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @returns {object}
     */
    Oas.prototype.getPaths = function () {
        var _this = this;
        // Because a path doesn't need to contain a keyed-object of HTTP methods, we should exclude anything from within
        // the paths object that isn't a known HTTP method.
        // https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.0.md#fixed-fields-7
        // https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#fixed-fields-7
        var supportedMethods = new Set(['get', 'put', 'post', 'delete', 'options', 'head', 'patch', 'trace']);
        var paths = {};
        Object.keys(this.paths ? this.paths : []).forEach(function (path) {
            paths[path] = {};
            Object.keys(_this.paths[path]).forEach(function (method) {
                if (!supportedMethods.has(method))
                    return;
                paths[path][method] = _this.operation(path, method);
            });
        });
        return paths;
    };
    /**
     * Returns the `webhooks` object that exists in this API definition but with every `method` mapped to an instance of
     * the `Operation` class.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @returns {object}
     */
    Oas.prototype.getWebhooks = function () {
        var _this = this;
        var webhooks = {};
        Object.keys(this.webhooks ? this.webhooks : []).forEach(function (id) {
            webhooks[id] = {};
            Object.keys(_this.webhooks[id]).forEach(function (method) {
                webhooks[id][method] = _this.operation(id, method, { isWebhook: true });
            });
        });
        return webhooks;
    };
    /**
     * Return an array of all tag names that exist on this API definition.
     *
     * Note: This method right now does **not** factor in webhooks that have tags.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @param {boolean} setIfMissing If a tag is not present on an operation that operations path will be added into the
     *    list of tags returned.
     * @returns {array}
     */
    Oas.prototype.getTags = function (setIfMissing) {
        if (setIfMissing === void 0) { setIfMissing = false; }
        var allTags = new Set();
        Object.entries(this.getPaths()).forEach(function (_a) {
            var _b = __read(_a, 2), path = _b[0], operations = _b[1];
            Object.values(operations).forEach(function (operation) {
                var tags = operation.getTags();
                if (setIfMissing && !tags.length) {
                    allTags.add(path);
                    return;
                }
                tags.forEach(function (tag) {
                    allTags.add(tag.name);
                });
            });
        });
        return __spreadArray([], __read(allTags), false);
    };
    /**
     * Dereference the current OAS definition so it can be parsed free of worries of `$ref` schemas and circular
     * structures.
     *
     * @returns {Promise<void>}
     */
    Oas.prototype.dereference = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _dereferencing, _promises, user, oas;
            var _this = this;
            return __generator(this, function (_b) {
                if (this._dereferencing.complete) {
                    return [2 /*return*/, new Promise(function (resolve) { return resolve(); })];
                }
                if (this._dereferencing.processing) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            _this._promises.push({ resolve: resolve, reject: reject });
                        })];
                }
                this._dereferencing.processing = true;
                _a = this, _dereferencing = _a._dereferencing, _promises = _a._promises, user = _a.user, oas = __rest(_a, ["_dereferencing", "_promises", "user"]);
                // Because referencing will eliminate any lineage back to the original `$ref`, information that we might need at
                // some point, we should run through all available component schemas and denote what their name is so that when
                // dereferencing happens below those names will be preserved.
                if (oas && oas.components && oas.components.schemas && typeof oas.components.schemas === 'object') {
                    Object.keys(oas.components.schemas).forEach(function (schemaName) {
                        oas.components.schemas[schemaName]['x-readme-ref-name'] = schemaName;
                    });
                }
                return [2 /*return*/, $RefParser
                        .dereference(oas, {
                        resolve: {
                            // We shouldn't be resolving external pointers at this point so just ignore them.
                            external: false
                        },
                        dereference: {
                            // If circular `$refs` are ignored they'll remain in the OAS as `$ref: String`, otherwise `$refâ€˜ just won't
                            // exist. This allows us to do easy circular reference detection.
                            circular: 'ignore'
                        }
                    })
                        .then(function (dereferenced) {
                        Object.assign(_this, dereferenced);
                        _this.user = user;
                        _this._promises = _promises;
                        _this._dereferencing = {
                            processing: false,
                            complete: true
                        };
                    })
                        .then(function () {
                        return _this._promises.map(function (deferred) { return deferred.resolve(); });
                    })];
            });
        });
    };
    return Oas;
}());
module.exports = Oas;
module.exports.Operation = Operation;
module.exports.Callback = Callback;
module.exports.Webhook = Webhook;
module.exports.utils = utils;
