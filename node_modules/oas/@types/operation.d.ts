export = Operation;
declare class Operation {
    constructor(oas: any, path: any, method: any, operation: any);
    schema: any;
    oas: any;
    path: any;
    method: any;
    contentType: any;
    requestBodyExamples: (false | {
        mediaType: string;
        examples: any;
    })[];
    responseExamples: (false | {
        status: string;
        mediaTypes: {};
    })[];
    callbackExamples: any[];
    getContentType(): any;
    isFormUrlEncoded(): any;
    isMultipart(): any;
    isJson(): any;
    isXml(): any;
    /**
     * Returns an array of all security requirements associated wtih this operation. If none are defined at the operation
     * level, the securities for the entire API definition are returned (with an empty array as a final fallback).
     *
     * @returns {array}
     */
    getSecurity(): any;
    /**
     * @see {@link https://swagger.io/docs/specification/authentication/#multiple}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#security-requirement-object}
     * @param {boolean} filterInvalid Optional flag that, when set to `true`, filters out invalid/nonexistent security
     *    schemes, rather than returning `false`.
     * @returns {array} An array of arrays of objects of grouped security schemes. The inner array determines and-grouped
     *    security schemes, the outer array determines or-groups.
     */
    getSecurityWithTypes(filterInvalid?: boolean): any;
    /**
     * @returns An object where the keys are unique scheme types,
     * and the values are arrays containing each security scheme of that type.
     */
    prepareSecurity(): any;
    getHeaders(): {
        request: any[];
        response: any[];
    };
    headers: {
        request: any[];
        response: any[];
    };
    /**
     * Determine if the operation has an operation present in its schema.
     *
     * @return {boolean}
     */
    hasOperationId(): boolean;
    /**
     * Get an `operationId` for this operation. If one is not present (it's not required by the spec!) a hash of the path
     * and method will be returned instead.
     *
     * @return {string}
     */
    getOperationId(): string;
    /**
     * Return an array of all tags, and their metadata, that exist on this operation.
     *
     * @returns {array}
     */
    getTags(): any;
    /**
     * Return is the operation is flagged as `deprecated` or not.
     *
     * @returns {boolean}
     */
    isDeprecated(): boolean;
    /**
     * Return the parameters (non-request body) on the operation.
     *
     * @todo This should also pull in common params.
     * @return {array}
     */
    getParameters(): any;
    /**
     * Convert the operation into an array of JSON Schema for each available type of parameter available on the operation.
     * `globalDefaults` contains an object of user defined parameter defaults used in constructSchema
     *
     * @param {Object} globalDefaults
     * @return {array}
     */
    getParametersAsJsonSchema(globalDefaults: Object): any;
    /**
     * Get a single response for this status code, formatted as JSON schema
     * @param {*} statusCode
     * @returns
     */
    getResponseAsJsonSchema(statusCode: any): {
        type: any;
        schema: any;
        label: string;
    }[];
    /**
     * Get an array of all valid response status codes for this operation
     * @param {*} statusCode
     * @returns
     */
    getResponseStatusCodes(): string[];
    /**
     * Determine if the operation has a request body.
     *
     * @return {boolean}
     */
    hasRequestBody(): boolean;
    /**
     * Retrieve an array of request body examples that this operation has.
     *
     * @returns {array}
     */
    getRequestBodyExamples(): any;
    /**
     * Return a specific response out of the operation by a given HTTP status code.
     *
     * @param {integer} statusCode
     * @return {(boolean|object)}
     */
    getResponseByStatusCode(statusCode: any): (boolean | object);
    /**
     * Retrieve an array of response examples that this operation has.
     *
     * @returns {array}
     */
    getResponseExamples(): any;
    /**
     * Determine if the operation has callbacks.
     *
     * @return {boolean}
     */
    hasCallbacks(): boolean;
    /**
     * Retrieve a specific callback
     *
     * @returns {Operation}
     */
    getCallback(identifier: any, expression: any, method: any): Operation;
    /**
     * Retrieve an array of operations created from each callback.
     *
     * @returns {array}
     */
    getCallbacks(): any;
    /**
     * Retrieve an array of callback examples that this operation has.
     *
     * @returns {array}
     */
    getCallbackExamples(): any;
}
declare namespace Operation {
    export { Callback, Webhook };
}
declare class Callback extends Operation {
    constructor(oas: any, path: any, method: any, operation: any, identifier: any);
    identifier: any;
    /**
     * Return the primary identifier for this callback.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.3.md#callback-object}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#callbackObject}
     *
     * @returns {string}
     */
    getIdentifier(): string;
}
declare class Webhook extends Operation {
}
