export = Oas;
declare class Oas {
    constructor(oas: any, user: any);
    user: any;
    _promises: any[];
    _dereferencing: {
        processing: boolean;
        complete: boolean;
    };
    getVersion(): any;
    url(selected: number, variables: any): any;
    variables(selected?: number): any;
    defaultVariables(selected?: number): {};
    splitUrl(selected?: number): any;
    /**
     * With a fully composed server URL, run through our list of known OAS servers and return back which server URL was
     * selected along with any contained server variables split out.
     *
     * For example, if you have an OAS server URL of `https://{name}.example.com:{port}/{basePath}`, and pass in
     * `https://buster.example.com:3000/pet` to this function, you'll get back the following:
     *
     *    { selected: 0, variables: { name: 'buster', port: 3000, basePath: 'pet' } }
     *
     * Re-supplying this data to `oas.url()` should return the same URL you passed into this method.
     *
     * @param {String} baseUrl
     * @returns {Object|Boolean}
     */
    splitVariables(baseUrl: string): Object | boolean;
    /**
     * Replace templated variables with supplied data in a given URL.
     *
     * There are a couple ways that this will utilize variable data:
     *
     *  - If data is stored in `this.user` and it matches up with the variable name in the URL user data
     *    will always take priority. See `getUserVariable` for some more information on how this data is pulled from
     *    `this.user`.
     *  - Supplying a `variables` object. This incoming `variables` object can be two formats:
     *    `{ variableName: { default: 'value' } }` and `{ variableName: 'value' }`. If the former is present, that will
     *    take prescendence over the latter.
     *
     * If no variables supplied match up with the template name, the template name will instead be used as the variable
     * data.
     *
     * @param {String} url
     * @param {Object} variables
     * @returns String
     */
    replaceUrl(url: string, variables?: Object): any;
    operation(path: any, method: any, opts?: {}): Operation.Webhook | Operation;
    findOperationMatches(url: any): {
        url: {
            origin: any;
            path: any;
            nonNormalizedPath: string;
            slugs: {};
        };
        operation: any;
        match: import("path-to-regexp").Match<object>;
    }[];
    /**
     * Discover an operation in an OAS from a fully-formed URL and HTTP method. Will return an object containing a `url`
     * object and another one for `operation`. This differs from `getOperation()` in that it does not return an instance
     * of the `Operation` class.
     *
     * @param {String} url
     * @param {String} method
     * @return {(Object|undefined)}
     */
    findOperation(url: string, method: string): (Object | undefined);
    /**
     * Discover an operation in an OAS from a fully-formed URL without an HTTP method. Will return an object containing a `url`
     * object and another one for `operation`.
     *
     * @param {String} url
     * @return {(Object|undefined)}
     */
    findOperationWithoutMethod(url: string): (Object | undefined);
    /**
     * Retrieve an operation in an OAS from a fully-formed URL and HTTP method. Differs from `findOperation` in that while
     * this method will return an `Operation` instance, `findOperation()` does not.
     *
     * @param {String} url
     * @param {String} method
     * @return {(Operation|undefined)}
     */
    getOperation(url: string, method: string): (Operation | undefined);
    /**
     * With an object of user information, retrieve an appropriate API key from the current OAS definition.
     *
     * @see {@link https://docs.readme.com/docs/passing-data-to-jwt}
     * @param {Object} user
     * @param {Boolean|String} selectedApp
     */
    getAuth(user: Object, selectedApp?: boolean | string): Record<string, unknown>;
    /**
     * Returns the `paths` object that exists in this API definition but with every `method` mapped to an instance of
     * the `Operation` class.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @returns {object}
     */
    getPaths(): object;
    /**
     * Returns the `webhooks` object that exists in this API definition but with every `method` mapped to an instance of
     * the `Operation` class.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @returns {object}
     */
    getWebhooks(): object;
    /**
     * Return an array of all tag names that exist on this API definition.
     *
     * Note: This method right now does **not** factor in webhooks that have tags.
     *
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.0.0.md#oasObject}
     * @see {@link https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#openapi-object}
     * @param {boolean} setIfMissing If a tag is not present on an operation that operations path will be added into the
     *    list of tags returned.
     * @returns {array}
     */
    getTags(setIfMissing?: boolean): any;
    /**
     * Dereference the current OAS definition so it can be parsed free of worries of `$ref` schemas and circular
     * structures.
     *
     * @returns {Promise<void>}
     */
    dereference(): Promise<void>;
}
declare namespace Oas {
    export { Operation, Callback, Webhook, utils };
}
import Operation = require("./operation");
import { Callback } from "./operation";
import { Webhook } from "./operation";
import utils_1 = require("./utils");
import utils = utils_1.default;
