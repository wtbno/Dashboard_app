import NeDB from 'nedb';
import type { BaseModel } from '../models/index';
export interface Query {
    _id?: string | SpecificQuery;
    parentId?: string | null;
    remoteId?: string | null;
    plugin?: string;
    key?: string;
    environmentId?: string | null;
    protoFileId?: string;
}
declare type Sort = Record<string, any>;
interface Operation {
    upsert?: BaseModel[];
    remove?: BaseModel[];
}
export interface SpecificQuery {
    $gt?: number;
    $in?: string[];
    $nin?: string[];
}
export declare type ModelQuery<T extends BaseModel> = Partial<Record<keyof T, SpecificQuery>>;
export declare const database: {
    all: <T extends BaseModel>(type: string) => Promise<T[]>;
    batchModifyDocs: ({ upsert, remove }: Operation) => Promise<void>;
    /** buffers database changes and returns a buffer id */
    bufferChanges: (millis?: number) => Promise<number>;
    /** buffers database changes and returns a buffer id */
    bufferChangesIndefinitely: () => Promise<number>;
    CHANGE_INSERT: string;
    CHANGE_UPDATE: string;
    CHANGE_REMOVE: string;
    count: <T_1 extends BaseModel>(type: string, query?: Query) => Promise<number>;
    docCreate: <T_2 extends BaseModel>(type: string, ...patches: Partial<T_2>[]) => Promise<T_2>;
    docUpdate: <T_3 extends BaseModel>(originalDoc: T_3, ...patches: Partial<T_3>[]) => Promise<T_3>;
    duplicate: <T_4 extends BaseModel>(originalDoc: T_4, patch?: Partial<T_4>) => Promise<T_4>;
    find: <T_5 extends BaseModel>(type: string, query?: Query | string, sort?: Sort) => Promise<T_5[]>;
    findMostRecentlyModified: <T_6 extends BaseModel>(type: string, query?: Query, limit?: number | null) => Promise<T_6[]>;
    flushChanges: (id?: number, fake?: boolean) => Promise<void>;
    flushChangesAsync: (fake?: boolean) => Promise<void>;
    get: <T_7 extends BaseModel>(type: string, id?: string | undefined) => Promise<T_7 | null>;
    getMostRecentlyModified: <T_8 extends BaseModel>(type: string, query?: Query) => Promise<T_8 | null>;
    getWhere: <T_9 extends BaseModel>(type: string, query: Query | Partial<Record<keyof T_9, SpecificQuery>>) => Promise<T_9 | null>;
    init: (types: string[], config?: NeDB.DataStoreOptions, forceReset?: boolean, consoleLog?: typeof console.log) => Promise<void>;
    initClient: () => Promise<void>;
    insert: <T_10 extends BaseModel>(doc: T_10, fromSync?: boolean, initializeModel?: boolean) => Promise<T_10>;
    onChange: (callback: ChangeListener) => void;
    offChange: (callback: ChangeListener) => void;
    remove: <T_11 extends BaseModel>(doc: T_11, fromSync?: boolean) => Promise<void>;
    removeWhere: <T_12 extends BaseModel>(type: string, query: Query) => Promise<void>;
    /** Removes entries without removing their children */
    unsafeRemove: <T_13 extends BaseModel>(doc: T_13, fromSync?: boolean) => Promise<void>;
    update: <T_14 extends BaseModel>(doc: T_14, fromSync?: boolean) => Promise<T_14>;
    upsert: <T_15 extends BaseModel>(doc: T_15, fromSync?: boolean) => Promise<T_15>;
    withAncestors: <T_16 extends BaseModel>(doc: T_16 | null, types?: string[]) => Promise<T_16[]>;
    withDescendants: <T_17 extends BaseModel>(doc: T_17 | null, stopType?: string | null) => Promise<BaseModel[]>;
};
declare type ChangeListener = Function;
declare type Patch<T> = Partial<T>;
/**
 * Run various database repair scripts
 */
export declare function _repairDatabase(): Promise<void>;
export {};
//# sourceMappingURL=database.d.ts.map