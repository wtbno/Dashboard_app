import { Settings } from 'insomnia-common';
import { ErrorResult, InsomniaConfig } from 'insomnia-config/dist';
interface FailedParseResult {
    syntaxError: SyntaxError;
    fileContents: string;
    configPath: string;
}
/** takes an unresolved (or resolved will work fine too) filePath of the insomnia config and reads the insomniaConfig from disk */
export declare const readConfigFile: (configPath?: string | undefined) => unknown | FailedParseResult | undefined;
export declare const getLocalDevConfigFilePath: () => string | undefined;
export declare const getConfigFile: () => FailedParseResult | {
    insomniaConfig: unknown;
    configPath: string;
};
export interface ConfigError {
    error: {
        configPath?: string;
        insomniaConfig: unknown;
        errors: ErrorResult['errors'];
        humanReadableErrors: ErrorResult['humanReadableErrors'];
    };
}
export declare const isConfigError: (input: ConfigError | ParseError) => input is ConfigError;
export interface ParseError {
    error: FailedParseResult;
}
export declare const isParseError: (input: ConfigError | ParseError) => input is ParseError;
/**
 * gets settings from the `insomnia.config.json`
 *
 * note that it is a business rule that the config is never read again after startup, hence the `once` usage.
 */
export declare const getConfigSettings: () => (NonNullable<InsomniaConfig['settings']> | ConfigError | ParseError);
/** checks whether a given setting is literally specified in the insomnia config */
export declare const isControlledByConfig: (setting: keyof Settings | null) => boolean;
export interface SettingControlledSetting<T extends keyof Settings> {
    controlledValue: Settings[T];
    controller: keyof Settings;
    isControlled: true;
}
export interface ConfigControlledSetting<T extends keyof Settings> {
    controlledValue: Settings[T];
    controller: 'insomnia-config';
    isControlled: true;
}
export interface UncontrolledSetting {
    controller: null;
    isControlled: false;
}
export declare type SettingsControl<T extends keyof Settings> = SettingControlledSetting<T> | ConfigControlledSetting<T> | UncontrolledSetting;
/**
 * checks whether a given setting is controlled by another setting.
 * if so, it will return that setting id.  otherwise it will return false.
 */
export declare const isControlledByAnotherSetting: (settings: Settings) => (setting: keyof Settings) => SettingControlledSetting<keyof Settings> | UncontrolledSetting;
/**
 * For any given setting, return what the value of that setting should be once you take the insomnia config and other potentially controlling settings into account
 */
export declare const getControlledStatus: (userSettings: Settings) => (setting: keyof Settings) => {
    controller: string;
    isControlled: boolean;
    value: string | number | boolean | import("insomnia-common").HotKeyRegistry | import("insomnia-common").PluginConfigMap | null | undefined;
} | {
    controller: null;
    isControlled: boolean;
    value: string | number | boolean | import("insomnia-common").HotKeyRegistry | import("insomnia-common").PluginConfigMap | null | undefined;
};
/** removes any setting in the given patch object which is controlled in any way (i.e. either by the insomnia config or by another setting) */
export declare const omitControlledSettings: <T extends Settings, U extends Partial<Settings>>(settings: T, patch: U) => U;
/** for any given setting, whether controlled by the insomnia config or whether controlled by another value, return the calculated value */
export declare const getMonkeyPatchedControlledSettings: <T extends Settings>(settings: T) => T;
export {};
//# sourceMappingURL=settings.d.ts.map