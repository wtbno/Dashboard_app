import * as git from 'isomorphic-git';
export interface GitAuthor {
    name: string;
    email: string;
}
export interface GitRemoteConfig {
    remote: string;
    url: string;
}
interface GitCredentialsPassword {
    username: string;
    password: string;
}
interface GitCredentialsToken {
    username: string;
    token: string;
}
export declare type GitCredentials = GitCredentialsPassword | GitCredentialsToken;
export declare type GitHash = string;
export declare type GitRef = GitHash | string;
export interface GitTimestamp {
    timezoneOffset: number;
    timestamp: number;
}
export interface GitLogEntry {
    oid: string;
    commit: {
        message: string;
        tree: GitRef;
        author: GitAuthor & GitTimestamp;
        committer: GitAuthor & GitTimestamp;
        parent: GitRef[];
    };
    payload: string;
}
interface InitOptions {
    directory: string;
    fs: git.FsClient;
    gitDirectory?: string;
}
interface InitFromCloneOptions {
    url: string;
    gitCredentials?: GitCredentials | null;
    directory: string;
    fs: git.FsClient;
    gitDirectory: string;
}
/**
 * isomorphic-git internally will default an empty ('') clone directory to '.'
 *
 * Ref: https://github.com/isomorphic-git/isomorphic-git/blob/4e66704d05042624bbc78b85ee5110d5ee7ec3e2/src/utils/normalizePath.js#L10
 *
 * We should set this explicitly (even if set to an empty string), because we have other code (such as fs clients and unit tests) that depend on the clone directory.
 */
export declare const GIT_CLONE_DIR = ".";
export declare const GIT_INSOMNIA_DIR_NAME = ".insomnia";
export declare const GIT_INTERNAL_DIR: string;
export declare const GIT_INSOMNIA_DIR: string;
interface BaseOpts {
    dir: string;
    gitdir?: string;
    fs: git.CallbackFsClient | git.PromiseFsClient;
    http: git.HttpClient;
    onMessage: (message: string) => void;
    onAuthFailure: (message: string) => void;
    onAuthSuccess: (message: string) => void;
    onAuth: () => void;
}
export declare class GitVCS {
    _baseOpts: BaseOpts;
    initialized: boolean;
    constructor();
    init({ directory, fs, gitDirectory }: InitOptions): Promise<void>;
    initFromClone({ url, gitCredentials, directory, fs, gitDirectory }: InitFromCloneOptions): Promise<void>;
    isInitialized(): boolean;
    listFiles(): Promise<string[]>;
    getBranch(): Promise<string>;
    listBranches(): Promise<string[]>;
    listRemoteBranches(): Promise<string[]>;
    status(filepath: string): Promise<"modified" | "ignored" | "unmodified" | "*modified" | "*deleted" | "*added" | "absent" | "deleted" | "added" | "*unmodified" | "*absent" | "*undeleted" | "*undeletemodified">;
    add(relPath: string): Promise<void>;
    remove(relPath: string): Promise<void>;
    addRemote(url: string): Promise<GitRemoteConfig>;
    listRemotes(): Promise<GitRemoteConfig[]>;
    getAuthor(): Promise<GitAuthor>;
    setAuthor(name: string, email: string): Promise<void>;
    getRemote(name: string): Promise<GitRemoteConfig | null>;
    commit(message: string): Promise<string>;
    /**
     * Check to see whether remote is different than local. This is here because
     * when pushing with isomorphic-git, if the HEAD of local is equal the HEAD
     * of remote, it will fail with a non-fast-forward message.
     *
     * @param gitCredentials
     * @returns {Promise<boolean>}
     */
    canPush(gitCredentials?: GitCredentials | null): Promise<boolean>;
    push(gitCredentials?: GitCredentials | null, force?: boolean): Promise<void>;
    pull(gitCredentials?: GitCredentials | null): Promise<void>;
    merge(theirBranch: string): Promise<git.MergeResult>;
    fetch(singleBranch: boolean, depth: number, gitCredentials?: GitCredentials | null): Promise<git.FetchResult>;
    log(depth?: number): Promise<git.ReadCommitResult[]>;
    branch(branch: string, checkout?: boolean): Promise<void>;
    deleteBranch(branch: string): Promise<void>;
    checkout(branch: string): Promise<void>;
    undoPendingChanges(fileFilter?: String[]): Promise<void>;
    readObjFromTree(treeOid: string, objPath: string): Promise<string | Uint8Array | git.CommitObject | git.TreeEntry[] | git.TagObject | null>;
    repoExists(): Promise<boolean>;
    getFs(): git.CallbackFsClient | git.PromiseFsClient;
    static sortBranches(branches: string[]): string[];
}
export {};
//# sourceMappingURL=git-vcs.d.ts.map